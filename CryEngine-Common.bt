//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: CryEngine-Common.bt
//   Authors: Geoff Gerber
//   Version: 0.1
//   Purpose: Common structs and functions for all CryEngine versions
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef COMMON_H
#define COMMON_H

#include "Cryengine-Structs.bt"
#include "Cryengine-Enums.bt"

typedef short snorm <read=Read_SNORM>;
typedef ushort unorm <read=Read_UNORM>;

string Read_SNORM(short s) {
    string t;
    float f = Max(s/32767.0, -1.0);
    SPrintf( t, "%g", f );
    return t;
};

string Read_UNORM(ushort s) {
    string t;
    float f = s/65535.0;
    SPrintf( t, "%g", f );
    return t;
};

struct BONEMAPDATA(int bytesPerElement) {
    if (bytesPerElement == 8) {
        byte boneIndex[4];
        byte weight[4];
    }
    else if (bytesPerElement == 12) {
        ushort boneIndex[4];
        byte weight[4];
    }
    else if (bytesPerElement == 24) {
        uint boneIndex[4];
        short weight[4];
    };
};

struct BONEMAP(int numberOfVertices) {
    uint bytesPerElement;
    BONEMAPDATA bonemap(bytesPerElement)[numberOfVertices] <comment=PrintBoneMapData>;
};

struct UNKNOWN_4BYTE {
    byte x;
    byte y;
    byte z;
    byte w;
};

struct UNKNOWN2 {
    UNKNOWN_4BYTE dataBlock[6];
};

struct UNKNOWN(int numberOfVertices) {
    uint bytesPerElement;
    UNKNOWN2 unknown[numberOfVertices];
};

struct QUATERION {
    float x;
    float y;
    float z;
    float w;
};

string GetQuaterion(QUATERION &quat) {
    string result;
    SPrintf(result, "[%f, %f, %f, %f]", quat.x, quat.y, quat.z, quat.w);
    return result;
};

struct COLOR {
    ubyte red;
    ubyte blue;
    ubyte green;
    ubyte alpha;
};

struct UVHalf {
    hfloat u;
    hfloat v;
};

struct TANGENT_BYTE {
    byte x;
    byte y;
    byte z;
    byte w;
};

string PrintTangentByte(TANGENT_BYTE &tan) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", tan.x/127.0, tan.y/127.0, tan.z/127.0, tan.w/127.0);
    return result;
}

string PrintTangent(TANGENT_BYTE &tan) {
    string result;
    local VECTOR3 tangent;
    tangent.x = (2 * (tan.x/127.0 * tan.z/127.0 + tan.y/127.0 * tan.w/127.0));
    tangent.y = (2 * (tan.y/127.0 * tan.z/127.0 - tan.x/127.0 * tan.w/127.0));
    tangent.z = (2 * (tan.z/127.0 * tan.z/127.0 + tan.w/127.0 * tan.w/127.0)) - 1;
    SPrintf(result, "%f, %f, %f", tangent.x, tangent.y, tangent.z);
    return result;
};

float CryHalfToFloat(ushort value) {
    uint Mantissa;
    uint Exponent;
    uint Result;

    Mantissa = (uint)(Value & 0x03FF);

    if ((Value & 0x7C00) != 0)  // The value is normalized
    {
        Exponent = (uint)((Value >> 10) & 0x1F);
    }
    else if (Mantissa != 0)     // The value is denormalized
    {
        // Normalize the value in the resulting float
        Exponent = 1;

        do
        {
            Exponent--;
            Mantissa <<= 1;
        } while ((Mantissa & 0x0400) == 0);

        Mantissa &= 0x03FF;
    }
    else                        // The value is zero
    {
        Exponent = (uint)-112;
    }

    Result = ((Value & 0x8000) << 16) | // Sign
        ((Exponent + 112) << 23) | // Exponent
        (Mantissa << 13);          // Mantissa

    return (float)Result;
};

#endif
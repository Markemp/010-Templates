//------------------------------------------------
//--- 010 Editor v8.0 Binary Template
//
//      File: CryEngine-Structs.bt
//   Authors: Geoffrey Gerber
//   Version: 1.0
//   Purpose: Structures used in newer Cryengine games (Star Citizen specific)
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef STRUCTS_38_H
#define STRUCTS_38_H

#include "Cryengine3.8-Enums.bt"
#include "Cryengine-Structs.bt"
#include "Cryengine-Helpers.bt"

struct HEADER {
    char fileSig[4];
    uint version <format=hex>;
    uint numChunks;
    int fileOffset;  // location of header chunks
};

string GetChunkTableType(CHUNKTABLEENTRY &entry) {
    string result;
    SPrintf(result, "Type = %s", EnumToString(entry.chunkType));
    return result;
};

struct CHUNK {
    uint fOffset <format=hex>;
    uint chunkType <format=hex>;
    uint version <format=hex>;
    uint id <format=hex>;
    uint size <format=hex>;
};

//struct NODECHUNK(int includeHeader) {
//    if (includeHeader) {
//        CHUNKHEADER nodeChunkHeaderInfo;
//    }
//    char name[64];
//    uint objectNodeId <format=hex>; // Mesh chunk ID
//    uint parentNodeId <format=hex>; // Chunk ID of parent node
//    uint numberOfChildren;
//    uint materialId <format=hex>;
//    uint skipBytes;                 // Obsolete info
//    MATRIX4x4 transform <comment=PrintMatrix4x4>;   
//    VECTOR3 position <comment=PrintVector3>;        // Obsolete
//    QUATERNION rotation <comment=PrintQuaternion>;  // Obsolete
//    VECTOR3 scale <comment=PrintVector3>;           // Obsolete
//    int controllerPos <format=hex>;
//    int rotationPos <format=hex>;
//    int scalePos <format=hex>;
//    int propertyStringLength <format=hex>;          // length of property string
//};

struct HELPER {
    uint type;  // Type of helper. 0=point,1=Dummy
    VECTOR3 Pos <comment=PrintVector3>;
};

struct MTLNAMECHUNK {
    char Name[128];
    int NumberOfSubmaterials;
    MtlNamePhysicsType SubMaterialChunkID[NumberOfSubmaterials];
};

struct SPEEDINFO {
    CHUNKHEADER chunkHeaderInfo;
    float speed;
    float distance;
    float slope;
    int animFlags;
    VECTOR3 moveDir <comment=PrintVector3>;
    QUATERNION startPosition;
};

struct PHYSICSGEOMETRY {
    int physicGeom;
    int flags;
    VECTOR3 minimum <comment=PrintVector3>;
    VECTOR3 maximum <comment=PrintVector3>;
    VECTOR3 spring_angle <comment=PrintVector3>;
    VECTOR3 spring_tension <comment=PrintVector3>;
    VECTOR3 damping <comment=PrintVector3>;
    MATRIX3x3 framemtx <comment=PrintMatrix3x3>;
};

struct COMPILEDBONE {
    uint controllerID;
    PHYSICSGEOMETRY physicsGeo[2];
    float mass;
    MATRIX3x4 worldToBone <comment=PrintMatrix3x4>;    //initialpose matrix World2Bone
    MATRIX3x4 boneToWorld <comment=PrintMatrix3x4>;
    char boneName[256];
    int limbID;
    int offsetParent;       // this bone parent is this[m_nOffsetParent], 0 if the bone is root. Normally this is <= 0
    uint numChildren;       // The whole hierarchy of bones is kept in one big array that belongs to the ModelState
                            // Each bone that has children has its own range of bone objects in that array,
                            // and this points to the beginning of that range and defines the number of bones.

    int offsetChild;        // the beginning of the subarray of children is at this[m_nOffsetChildren]
                            // this is 0 if there are no children
};

struct COMPILEDBONESCHUNK(int numberOfBones) {
    char padding[32];
    COMPILEDBONE bones(numberOfBones) <bgcolor=cDkRed>;
};

struct COMPILEDPHYSICALBONE {       // A lot of these are guesses.
    uint boneID;            // The number of the bone found.  Index in COMPILEDBONE
    uint parentID;          // Index of the parent bone
    uint numChildren;       // Number of child bones
    uint controllerID;      // controllerID for this bone.
    char prop[32];          // 32 byte char array
    PHYSICSGEOMETRY phys;   // physics.
};

struct COMPILEDPHYSICALBONESCHUNK(int numberOfBones) {
    char buffer[32];
    COMPILEDPHYSICALBONE physicalBones[numberOfBones];
};

struct COMPILEDBONES(int numberOfBones) {
    char padding[32];
    COMPILEDBONE bones[numberOfBones];
};

//struct MESHCHUNK {
//    uint Flags1;
//    uint Flags2;
//    uint NumVertices;
//    uint NumIndices;
//    uint NumVertSubsets; // 801 format
//    uint MeshSubsets;
//    uint VerticesData <format=hex>;
//    uint Unknown <format=hex>;
//    uint NormalsData <format=hex>;
//    uint UVsData <format=hex>;
//    uint ColorsData <format=hex>;
//    uint Colors2Data <format=hex>;
//    uint IndicesData <format=hex>;
//    uint TangentsData <format=hex>;
//    uint ShCoeffsData <format=hex>;
//    uint ShapeDeformationData <format=hex>;
//    uint BoneMapData <format=hex>;
//    uint FaceMapData <format=hex>;
//    uint VertMatsData <format=hex>;
//    uint QTangentsData <format=hex>; // 801 format
//    uint SkinData;
//    uint Dummy2;                    // Old console data
//    uint VertsUVData <format=hex>;
//    uint PhysicsData[4] <format=hex>;
//    VECTOR3 MinBound;
//    VECTOR3 MaxBound;
//};

struct BREAKABLEPHYSICSCHUNK {
    uint granularity;
    int nMode;
    int nRetVtx;
    int nRetTets;
    int reserved[10];
};

//struct DATASTREAMCHUNK {
//    local int i;
//    
//    uint flags2;
//    DATASTREAMTYPE datastreamType;
//    uint numberOfElements;
//    ushort bytesPerElement;
//    ushort unknown;
//    
//    switch (datastreamType) {
//        case VERTICES: {
//            uint flags[2];
//            for (i = 0; i < numberOfElements; i++) {
//                VECTOR3 vertices <comment=PrintVector3>;
//            }   
//            break;
//        }
//        case VERTSUVS: {
//            uint flags[2];
//            for (i = 0; i < numberOfElements; i++) {
//                VERTSUV vertsUvs(bytesPerElement) <comment=PrintVertsUvs>;
//            }
//            break;
//        }
//        case NORMALS: {
//            uint flags[2];
//            VECTOR3 normals[numberOfElements] <comment=PrintVector3>;
//            break;
//        }
//        case UVS: {
//            uint flags[2];
//            UV uv[numberOfElements] <comment=PrintUV>;
//            break;   
//        }
//        case COLORS: {
//            uint flags[2];
//            IRGBA colors[numberOfElements] <comment=PrintColor>;
//            break;   
//        }
//        case INDICES: {
//            uint flags[2];
//            uint16 indices[numberOfElements];
//            break;   
//        }
//        case TANGENTS: {
//            uint flags[2];
//            VECTOR4SHORT tangent[numberOfElements];
//            break;   
//        }
//        case BONEMAPS: {
//            uint flags[2];
//            BONEMAPDATA boneMap(bytesPerElement)[numberOfElements];
//            break;
//        }
//        case QTANGENTS: {
//            uint flags[2];
//            QTANGENT qtangents[numberOfElements];
//        }
//        default: {
//            break;
//        }
//    }
//};

string GetDatastreamType(DATASTREAMCHUNK &datastream) {
    string result;
    SPrintf(result, "%s", EnumToString(datastream.datastreamType));
    return result;
};

#endif
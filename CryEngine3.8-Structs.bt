//------------------------------------------------
//--- 010 Editor v8.0 Binary Template
//
//      File: CryEngine-Structs.bt
//   Authors: Geoffrey Gerber
//   Version: 1.0
//   Purpose: Structures used in newer Cryengine games (Star Citizen specific)
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef STRUCTS_38_H
#define STRUCTS_38_H

#include "Cryengine3.8-Enums.bt"
#include "Cryengine-Structs.bt"
#include "Cryengine-Helpers.bt"

struct HEADER {
    char fileSig[4];
    uint version <format=hex>;
    uint numChunks;
    int fileOffset;  // location of header chunks
};

string GetChunkTableType(CHUNKTABLEENTRY &entry) {
    string result;
    SPrintf(result, "Type = %s", EnumToString(entry.chunkType));
    return result;
};

struct CHUNK {
    uint fOffset <format=hex>;
    uint chunkType <format=hex>;
    uint version <format=hex>;
    uint id <format=hex>;
    uint size <format=hex>;
};

struct HELPER {
    uint type;  // Type of helper. 0=point,1=Dummy
    VECTOR3 Pos <comment=PrintVector3>;
};

struct SPEEDINFO {
    CHUNKHEADER chunkHeaderInfo;
    float speed;
    float distance;
    float slope;
    int animFlags;
    VECTOR3 moveDir <comment=PrintVector3>;
    QUATERNION startPosition;
};

struct PHYSICSGEOMETRY {
    int physicGeom;
    int flags;
    VECTOR3 minimum <comment=PrintVector3>;
    VECTOR3 maximum <comment=PrintVector3>;
    VECTOR3 spring_angle <comment=PrintVector3>;
    VECTOR3 spring_tension <comment=PrintVector3>;
    VECTOR3 damping <comment=PrintVector3>;
    MATRIX3x3 framemtx <comment=PrintMatrix3x3>;
};

struct COMPILEDBONE {
    uint controllerID;
    PHYSICSGEOMETRY physicsGeo[2];
    float mass;
    MATRIX3x4 worldToBone <comment=PrintMatrix3x4>;    //initialpose matrix World2Bone
    MATRIX3x4 boneToWorld <comment=PrintMatrix3x4>;
    char boneName[256];
    int limbID;
    int offsetParent;       // this bone parent is this[m_nOffsetParent], 0 if the bone is root. Normally this is <= 0
    uint numChildren;       // The whole hierarchy of bones is kept in one big array that belongs to the ModelState
                            // Each bone that has children has its own range of bone objects in that array,
                            // and this points to the beginning of that range and defines the number of bones.

    int offsetChild;        // the beginning of the subarray of children is at this[m_nOffsetChildren]
                            // this is 0 if there are no children
};

struct COMPILEDBONESCHUNK(int numberOfBones) {
    char padding[32];
    COMPILEDBONE bones(numberOfBones) <bgcolor=cDkRed>;
};

struct COMPILEDPHYSICALBONE {       // A lot of these are guesses.
    uint boneID;            // The number of the bone found.  Index in COMPILEDBONE
    uint parentID;          // Index of the parent bone
    uint numChildren;       // Number of child bones
    uint controllerID;      // controllerID for this bone.
    char prop[32];          // 32 byte char array
    PHYSICSGEOMETRY phys;   // physics.
};

struct COMPILEDPHYSICALBONESCHUNK(int numberOfBones) {
    char buffer[32];
    COMPILEDPHYSICALBONE physicalBones[numberOfBones];
};

struct COMPILEDBONES(int numberOfBones) {
    char padding[32];
    COMPILEDBONE bones[numberOfBones];
};

struct BREAKABLEPHYSICSCHUNK {
    uint granularity;
    int nMode;
    int nRetVtx;
    int nRetTets;
    int reserved[10];
};

string GetDatastreamType(DATASTREAMCHUNK &datastream) {
    string result;
    SPrintf(result, "%s", EnumToString(datastream.datastreamType));
    return result;
};

#endif
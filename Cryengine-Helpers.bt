//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: Cryengine-Helpers.bt
//   Authors: Geoff Gerber
//   Version: 
//   Purpose: Useful functions for converting Cryengine files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef HELPERS_H
#define HELPERS_H

#include "Cryengine-Structs.bt"
#include "Cryengine-Enums.bt"
#include "Cryengine-Common.bt"

string PrintMatrix4x4(MATRIX4x4 &m) {
    string result;
    SPrintf(result, "[[%f, %f, %f, %f] [%f, %f, %f, %f] [%f, %f, %f, %f] [%f, %f, %f, %f]]", m.M11, m.M12, m.M13, m.M14, m.M21, m.M22, m.M23, m.M24, m.M31, m.M32, m.M33, m.M34, m.M41, m.M42, m.M43, m.M44);
    return result;
};

string PrintMatrix3x4(MATRIX3x4 &m) {
    string result;
    SPrintf(result, "[[%f, %f, %f, %f] [%f, %f, %f, %f] [%f, %f, %f, %f]]", m.M11, m.M12, m.M13, m.M14, m.M21, m.M22, m.M23, m.M24, m.M31, m.M32, m.M33, m.M34);
    return result;
};

string PrintMatrix3x3(MATRIX3x3 &m) {
    string result;
    SPrintf(result, "[[%f, %f, %f] [%f, %f, %f] [%f, %f, %f]]", m.M11, m.M12, m.M13, m.M21, m.M22, m.M23, m.M31, m.M32, m.M33);
    return result;
};

string PrintVector3(VECTOR3 &vertex) {
    string result;
    SPrintf(result, "%f, %f, %f", vertex.x, vertex.y, vertex.z);
    return result;
};

string PrintVector3Short(VECTOR3SHORT &vertex) {
    string result;
    SPrintf(result, "%f, %f, %f", vertex.x, vertex.y, vertex.z);
    return result;
};

string PrintVector3CryHalf(VECTOR3CRYHALF &vertex) {
    string result;
    SPrintf(result, "%f, %f, %f", CryHalfToFloat(vertex.x), CryHalfToFloat(vertex.y), CryHalfToFloat(vertex.z));
    return result;
};

string PrintVector4(VECTOR4 &vertex) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", vertex.x, vertex.y, vertex.z, vertex.w);
    return result;
};

string PrintQuaternion(QUATERNION &quat) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", quat.x, quat.y, quat.z, quat.w);
    return result;
};

string PrintQuatT(QuatT &qt) {
    string result;
    SPrintf(result, "q(%f, %f, %f, %f) t(%f, %f, %f)",
        qt.q.x, qt.q.y, qt.q.z, qt.q.w,
        qt.t.x, qt.t.y, qt.t.z);
    return result;
};

string PrintSmallTree48BitQuat(SmallTree48BitQuat &q) {
    // Decode SmallTree48BitQuat compression
    // Constants from CryEngine
    local float MAX_15BITf = 23170.0;
    local float RANGE_15BIT = 0.707106781186;

    // Reconstruct the 3 ushorts from raw bytes
    local uint m1 = q.data[0] | ((uint)q.data[1] << 8);
    local uint m2 = q.data[2] | ((uint)q.data[3] << 8);
    local uint m3 = q.data[4] | ((uint)q.data[5] << 8);

    // Combine into 64-bit value (use two 32-bit parts)
    local uint low32 = (m2 << 16) | m1;
    local uint high16 = m3;

    // maxComponentIndex is at bits 46-47
    local int maxIdx = (high16 >> 14) & 0x3;

    // Extract three 15-bit packed values
    local uint packed0 = low32 & 0x7FFF;
    local uint packed1 = (low32 >> 15) & 0x7FFF;
    local uint packed2 = ((low32 >> 30) | (high16 << 2)) & 0x7FFF;

    // Decode the three packed values
    local float decoded0 = packed0 / MAX_15BITf - RANGE_15BIT;
    local float decoded1 = packed1 / MAX_15BITf - RANGE_15BIT;
    local float decoded2 = packed2 / MAX_15BITf - RANGE_15BIT;

    // Assign to component array based on maxIdx
    local float comp0, comp1, comp2, comp3;
    local int srcIdx = 0;
    local int i;
    for (i = 0; i < 4; i++) {
        if (i == maxIdx) continue;
        if (srcIdx == 0) {
            if (i == 0) comp0 = decoded0;
            else if (i == 1) comp1 = decoded0;
            else if (i == 2) comp2 = decoded0;
            else comp3 = decoded0;
        } else if (srcIdx == 1) {
            if (i == 0) comp0 = decoded1;
            else if (i == 1) comp1 = decoded1;
            else if (i == 2) comp2 = decoded1;
            else comp3 = decoded1;
        } else {
            if (i == 0) comp0 = decoded2;
            else if (i == 1) comp1 = decoded2;
            else if (i == 2) comp2 = decoded2;
            else comp3 = decoded2;
        }
        srcIdx++;
    }

    // Reconstruct the max component: sqrt(1 - sum of squares)
    local float sqrsum = comp0*comp0 + comp1*comp1 + comp2*comp2 + comp3*comp3;
    local float maxComp = Sqrt(Max(0.0, 1.0 - sqrsum));

    if (maxIdx == 0) comp0 = maxComp;
    else if (maxIdx == 1) comp1 = maxComp;
    else if (maxIdx == 2) comp2 = maxComp;
    else comp3 = maxComp;

    string result;
    SPrintf(result, "x: %.4f, y: %.4f, z: %.4f, w: %.4f", comp0, comp1, comp2, comp3);
    return result;
};

string PrintSmallTree64BitQuat(SmallTree64BitQuat &q) {
    // Decode SmallTree64BitQuat compression
    local float MAX_20BITf = 741454.0;
    local float RANGE_20BIT = 0.707106781186;

    // Reconstruct the 2 uints from raw bytes
    local uint m1 = q.data[0] | ((uint)q.data[1] << 8) | ((uint)q.data[2] << 16) | ((uint)q.data[3] << 24);
    local uint m2 = q.data[4] | ((uint)q.data[5] << 8) | ((uint)q.data[6] << 16) | ((uint)q.data[7] << 24);

    // maxComponentIndex is at bits 62-63 (in m2 bits 30-31)
    local int maxIdx = (m2 >> 30) & 0x3;

    // Extract three 20-bit packed values
    local uint packed0 = m1 & 0xFFFFF;
    local uint packed1 = ((m1 >> 20) | (m2 << 12)) & 0xFFFFF;
    local uint packed2 = (m2 >> 8) & 0xFFFFF;

    // Decode the three packed values
    local float decoded0 = packed0 / MAX_20BITf - RANGE_20BIT;
    local float decoded1 = packed1 / MAX_20BITf - RANGE_20BIT;
    local float decoded2 = packed2 / MAX_20BITf - RANGE_20BIT;

    // Assign to component array based on maxIdx
    local float comp0, comp1, comp2, comp3;
    local int srcIdx = 0;
    local int i;
    for (i = 0; i < 4; i++) {
        if (i == maxIdx) continue;
        if (srcIdx == 0) {
            if (i == 0) comp0 = decoded0;
            else if (i == 1) comp1 = decoded0;
            else if (i == 2) comp2 = decoded0;
            else comp3 = decoded0;
        } else if (srcIdx == 1) {
            if (i == 0) comp0 = decoded1;
            else if (i == 1) comp1 = decoded1;
            else if (i == 2) comp2 = decoded1;
            else comp3 = decoded1;
        } else {
            if (i == 0) comp0 = decoded2;
            else if (i == 1) comp1 = decoded2;
            else if (i == 2) comp2 = decoded2;
            else comp3 = decoded2;
        }
        srcIdx++;
    }

    // Reconstruct the max component
    local float sqrsum = comp0*comp0 + comp1*comp1 + comp2*comp2 + comp3*comp3;
    local float maxComp = Sqrt(Max(0.0, 1.0 - sqrsum));

    if (maxIdx == 0) comp0 = maxComp;
    else if (maxIdx == 1) comp1 = maxComp;
    else if (maxIdx == 2) comp2 = maxComp;
    else comp3 = maxComp;

    string result;
    SPrintf(result, "x: %.4f, y: %.4f, z: %.4f, w: %.4f", comp0, comp1, comp2, comp3);
    return result;
};

string PrintSmallTree64BitExtQuat(SmallTree64BitExtQuat &q) {
    // Decode SmallTree64BitExtQuat compression
    // First two components use 21 bits, third uses 20 bits
    local float MAX_20BITf = 741454.0;
    local float RANGE_20BIT = 0.707106781186;
    local float MAX_21BITf = 1482909.0;
    local float RANGE_21BIT = 0.707106781186;

    // Reconstruct the 2 uints from raw bytes
    local uint m1 = q.data[0] | ((uint)q.data[1] << 8) | ((uint)q.data[2] << 16) | ((uint)q.data[3] << 24);
    local uint m2 = q.data[4] | ((uint)q.data[5] << 8) | ((uint)q.data[6] << 16) | ((uint)q.data[7] << 24);

    // maxComponentIndex is at bits 62-63 (in m2 bits 30-31)
    local int maxIdx = (m2 >> 30) & 0x3;

    // Extract packed values: 21 bits, 21 bits, 20 bits
    local uint packed0 = m1 & 0x1FFFFF;
    local uint packed1 = ((m1 >> 21) | (m2 << 11)) & 0x1FFFFF;
    local uint packed2 = (m2 >> 10) & 0xFFFFF;

    // Decode: first two use 21-bit constants, third uses 20-bit
    local float decoded0 = packed0 / MAX_21BITf - RANGE_21BIT;
    local float decoded1 = packed1 / MAX_21BITf - RANGE_21BIT;
    local float decoded2 = packed2 / MAX_20BITf - RANGE_20BIT;

    // Assign to component array based on maxIdx
    local float comp0, comp1, comp2, comp3;
    local int srcIdx = 0;
    local int i;
    for (i = 0; i < 4; i++) {
        if (i == maxIdx) continue;
        if (srcIdx == 0) {
            if (i == 0) comp0 = decoded0;
            else if (i == 1) comp1 = decoded0;
            else if (i == 2) comp2 = decoded0;
            else comp3 = decoded0;
        } else if (srcIdx == 1) {
            if (i == 0) comp0 = decoded1;
            else if (i == 1) comp1 = decoded1;
            else if (i == 2) comp2 = decoded1;
            else comp3 = decoded1;
        } else {
            if (i == 0) comp0 = decoded2;
            else if (i == 1) comp1 = decoded2;
            else if (i == 2) comp2 = decoded2;
            else comp3 = decoded2;
        }
        srcIdx++;
    }

    // Reconstruct the max component
    local float sqrsum = comp0*comp0 + comp1*comp1 + comp2*comp2 + comp3*comp3;
    local float maxComp = Sqrt(Max(0.0, 1.0 - sqrsum));

    if (maxIdx == 0) comp0 = maxComp;
    else if (maxIdx == 1) comp1 = maxComp;
    else if (maxIdx == 2) comp2 = maxComp;
    else comp3 = maxComp;

    string result;
    SPrintf(result, "x: %.4f, y: %.4f, z: %.4f, w: %.4f", comp0, comp1, comp2, comp3);
    return result;
};

string PrintByteKeyTime(ByteKeyTime &k) {
    string result;
    SPrintf(result, "%d", k.time);
    return result;
};

//string PrintCryNormal(CRYNORMAL &vertex) {
//    string result;
//    SPrintf(result, "%f, %f", vertex.x / 32767.0, vertex.y / 32767.0);
//    return result;
//};

string PrintTangentBitangent(TANGENTBITANGENT &d) {
    string result;
    SPrintf(result, "Tangent: x: %f, y: %f, z: %f, w: %f, Bitangent: x: %f, y: %f, z: %f, w: %f", 
        d.tangent.x / 32767.0, d.tangent.y / 32767.0, d.tangent.z / 32767.0, d.tangent.w / 32767.0, 
        d.bitangent.x / 32767.0, d.bitangent.y / 32767.0, d.bitangent.z / 32767.0, d.bitangent.w / 32767.0);
    return result;
};

string PrintMeshSubset(MESHSUBSET &meshSubset) {
    string result;
    SPrintf(result, "first vert: %d, num verts: %d, mat: %d", meshSubset.firstVertex, meshSubset.numberOfVertices, meshSubset.material);
    return result;
};

string PrintCryHalf(CRYHALF &half) {
    string result;
    SPrintf(result, "x: %d, y: %d, z: ??", half.x, half.y);
    return result;
};

string PrintBoneMapData(BONEMAPDATA &data) {
    string result;
    SPrintf(result, "Bone Index: [%d, %d, %d, %d], Weight: [%f, %f, %f, %f]", data.boneIndex[0], data.boneIndex[1], data.boneIndex[2], data.boneIndex[3], data.weight[0], data.weight[1], data.weight[2], data.weight[3]);
    return result;
};

string PrintBoneName(COMPILEDBONE &bone) {
    string result;
    SPrintf(result, "Name = %s", bone.boneName);
    return result;
};

string PrintVertsUvs(VERTSUV &m) {
    string result;
    SPrintf(result, "Verts: [%f, %f, %f], UVs: [%f, %f]", m.vertices.x, m.vertices.y, m.vertices.z, m.uv.u, m.uv.v);
    return result;
};

string PrintUV(UV &uv) {
    string result;
    SPrintf(result, "%f, %f", uv.u, uv.v);
    return result;
};

string PrintUVHalf(UVHALF &uv) {
    string result;
    SPrintf(result, "%f, %f", uv.u, uv.v);
    return result;
};

string PrintChunkTableType(CHUNKTABLEENTRY &entry) {
    string result;
    SPrintf(result, "Type = %s, Ver: %x", EnumToString(entry.chunkType.chunkType), entry.version);
    return result;
};

string GetMaterialName(MTLNAME &chunk) {
    string result;
    if (exists(chunk.mtlType)) {
        SPrintf(result, "Name: %s, Type: %s", chunk.Name, EnumToString(chunk.mtlType));
    } else {
        SPrintf(result, "Name: %s, Submats: %i", chunk.Name, chunk.NumberOfSubmaterials);
    }
    return result;
};

string PrintMatDetails(MTLNAME &mat) {
    string result;
    if (exists(mat.mtlType)) {
        local string matType = EnumToString(mat.mtlType);
        SPrintf(result, "Name: %s, Type: %s", mat.Name, matType);
    }
    else {
        SPrintf(result, "Name: %s", mat.Name);
    };
    
    return result;
};

string PrintColor(IRGBA &color) {
    string result;
    SPrintf(result, "%d, %d, %d, %d", color.r, color.g, color.b, color.a);
    return result;
};

string PrintColorB(COLORB &color) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", color.red / 255.0, color.green / 255.0, color.blue / 255.0, color.alpha / 255.0);
    return result;
};

string PrintIntSkinVertex(INTSKINVERTEX &vert) {
    string result;
    SPrintf(result, "Bone indes: [%d, %d, %d, %d], Weight: [%f, %f, %f, %f]", 
        vert.boneMapData.boneIndex[0], vert.boneMapData.boneIndex[1], vert.boneMapData.boneIndex[2], vert.boneMapData.boneIndex[3],
        vert.boneMapData.weight[0], vert.boneMapData.weight[1], vert.boneMapData.weight[2], vert.boneMapData.weight[3]);
    return result;
};

string PrintSourceInfo(SOURCEINFO &info) {
    string result;
    SPrintf(result, "%s", info.sourceFile);
    return result;
};

string GetNodeName(NODECHUNK &chunk) {
    string result;
    SPrintf(result, "Name = %s", chunk.name);
    return result;
};

string PrintDatastreamType(DATASTREAMCHUNK &datastream) {
    string result;
    SPrintf(result, "%s", EnumToString(datastream.datastreamType));
    return result;
};

string PrintExportFlags(EXPORTFLAGS &flags) {
    string result;
    SPrintf(result, "%s", flags.rcVersionString);
    return result;
};

string PrintTimingInfo(TIMINGINFO &info) {
    string result;
    SPrintf(result, "%s, range %d to %d", info.globalName, info.globalRangeStart, info.globalRangeEnd);
    return result;
};

string PrintTangentByte(TANGENT_BYTE &tan) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", tan.x/127.0, tan.y/127.0, tan.z/127.0, tan.w/127.0);
    return result;
}

string PrintBBox(BBOX &bbox) {
    string result;
    SPrintf(result, "Min: %f, %f, %f, Max: %f, %f, %f", bbox.min.x, bbox.min.y, bbox.min.z, bbox.max.x,bbox.max.y,bbox.max.z);
    return result;
};

uint SetDefaultVersion() {
    return 0x0800;
};

// Helper functions for sizes
int GetRotationSize(ubyte format) {
  switch (format) {
      case eNoCompress:
      case eNoCompressQuat:
          return 16;  // 4 floats (w,x,y,z)
      case eSmallTree48BitQuat:
          return 6;
      case eSmallTree64BitQuat:
      case eSmallTree64BitExtQuat:
          return 8;
      default:
          return 16;
  }
}

int GetPositionSize(ubyte format) {
  switch (format) {
      case eNoCompress:
      case eNoCompressVec3:
          return 12;  // 3 floats (x,y,z)
      default:
          return 12;
  }
}

int GetTimeKeySize(ubyte format) {
  switch (format) {
      case eF32:
      case eF32StartStop:
          return 4;
      case eUINT16:
      case eUINT16StartStop:
      case eBitset:
          return 2;
      case eByte:
      case eByteStartStop:
          return 1;
      default:
          return 4;
  }
}

// Align to 4-byte boundary
void AlignTo4() {
  local int pos = FTell();
  local int padding = (4 - (pos % 4)) % 4;
  if (padding > 0) {
      FSkip(padding);
  }
}

#endif
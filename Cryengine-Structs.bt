//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: CryEngine-Structs
//   Authors: Geoff Gerber
//   Version: v0.1
//   Purpose: Structs used in Cryengine files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
#ifndef STRUCTS_COMMON_H
#define STRUCTS_COMMON_H

struct VECTOR3 {
    float x;
    float y;
    float z;
};

struct VECTOR3SHORT {
    hfloat x;
    hfloat y;
    hfloat z;
};

struct VECTOR3CRYHALF {
    ushort x;
    ushort y;
    ushort z;
};

struct VECTOR4 {
    float x;
    float y;
    float z;
    float w;
};

struct VECTOR4SHORT {
    hfloat x;
    hfloat y;
    hfloat z;
    hfloat w;
};

struct QUATERNION {
    float x;
    float y;
    float z;
    float w;
};

struct MATRIX3x4 {
    float M11;
    float M12;
    float M13;
    float M14;
    float M21;
    float M22;
    float M23;
    float M24;
    float M31;
    float M32;
    float M33;
    float M34;
};

struct MATRIX3x3 {
    float M11;
    float M12;
    float M13;
    float M21;
    float M22;
    float M23;
    float M31;
    float M32;
    float M33;
};

struct MATRIX4x4 {
    float M11;
    float M12;
    float M13;
    float M14;
    float M21;
    float M22;
    float M23;
    float M24;
    float M31;
    float M32;
    float M33;
    float M34;
    float M41;
    float M42;
    float M43;
    float M44;
};

struct IRGBA {
    ubyte r;
    ubyte g;
    ubyte b;
    ubyte a;
};

struct UV {
    float u;
    float v;
};

struct UVHALF {
    hfloat u;
    hfloat v;
};

struct QTANGENT {
    short x;
    short y;
    short z;
    short w;
};

struct CHUNKHEADER(int fileVersion) {
    if (fileVersion == 0x0745) {
        CHUNKTYPE chunkType;
        uint version <format=hex>;
        uint offset <format=hex>;
        uint id <format=hex>;
    }
    else if (fileVersion == 0x0746) {
        // No chunk header in these.
    };
};

struct CONTROLLER_829 {
    uint controllerId;
    uint16 numberOfRotationKeys;
    uint16 numberOfPositionKeys;
    ubyte rotationFormat;
    ubyte rotationTimeFormat;
    ubyte positionFormat;
    ubyte positionKeyInfo;
    ubyte positionTimeFormat;
    ubyte tracksAligned;
};

struct CONTROLLER_905 {
    uint32 numKeyPos;
    uint32 numKeyRot;
    uint32 numKeyTime;
    uint32 numAnims;

    local uint i;
    // Key time lengths
    uint16 keyTime[numKeyTime];
    uint keyTimeFormat[7];
    uint16 keyPositionLength[numKeyPos];
    uint keyPositionFormat[9];
    uint16 keyRotationLength[numKeyRot];
    uint keyRotationFormat[9];
    uint keyTimeOffset[numKeyTime];
    uint keyPositionOffset[numKeyPos];
    uint keyRotationOffset[numKeyRot];
    uint trackLength;
};

struct VERTSUV(int bytesPerElement) {
    if (bytesPerElement == 16) {
        VECTOR3CRYHALF vertices <comment=PrintVector3CryHalf>;
        byte skip[2];
        IRGBA color <comment=PrintColor>;
        UVHALF uv <comment=PrintUVHalf>;
    }
    else if (bytesPerElement == 20) {
        VECTOR3 vertices <comment=PrintVector3>;
        IRGBA color <comment=PrintColor>;
        UV uv <comment=PrintUV>;
    };
};

struct BONEMAPDATA(int bytesPerElement) {
    if (bytesPerElement == 8) {
        byte boneIndex[4];
        byte weight[4];
    }
    else if (bytesPerElement == 12) {
        ushort boneIndex[4];
        byte weight[4];
    }
    else if (bytesPerElement == 24) {
        uint boneIndex[4];
        short weight[4];
    };
};

struct BONETOWORLD {
    float row1[4];
    float row2[4];
    float row3[4];
};

struct MESHSUBSET {
    uint firstVertex;
    uint numberOfVertices;
    uint firstIndex;
    uint numberOfIndices;
    uint material;
    float radius;
    VECTOR3 center <comment=PrintVector3>;
};

struct MESHSUBSETCHUNK {
    uint flags;
    uint numberOfMeshSubsets;
    byte skip[8];
    MESHSUBSET meshSubSet[numberOfMeshSubsets];
};

struct NODECHUNK(int fileVersion) {
    if (fileVersion == 0x0745) {
        CHUNKHEADER chunkHeader(fileVersion);
    }
    else if (fileVersion == 0x0746) {
    }; // no headers on these chunks
    char name[64];
    uint objectNodeId <format=hex>; // Mesh chunk ID
    uint parentNodeId <format=hex>; // Chunk ID of parent node
    uint numberOfChildren;
    uint materialId <format=hex>;
    uint skipBytes;                 // Obsolete info
    MATRIX4x4 transform <comment=PrintMatrix4x4>;   
    VECTOR3 position <comment=PrintVector3>;        // Obsolete
    QUATERNION rotation <comment=PrintQuaternion>;  // Obsolete
    VECTOR3 scale <comment=PrintVector3>;           // Obsolete
    int controllerPos <format=hex>;
    int rotationPos <format=hex>;
    int scalePos <format=hex>;
    int propertyStringLength <format=hex>;          // length of property string
};

struct CHUNKTABLEENTRY(uint ver) {
    CHUNKTYPE chunkType;
    uint version <format=hex>;  
    uint offset <format=hex>;
    uint id <format=hex>;
    if (ver == 0x0745) {
        uint size <format=hex>;
    }
    else {
        local uint size = 0;
    };
};

struct TIMINGINFO(int fileVersion) {
    if (fileVersion == 0x0745) {
        CHUNKHEADER chunkHeader (fileVersion);
    }
    else if (fileVersion == 0x0746) {
    }; // no headers on these chunks
    float secondsPerTick;
    int ticksPerFrame;
    char globalName[32];
    int globalRangeStart;
    int globalRangeEnd;
};

struct SOURCEINFO(CHUNKTABLEENTRY &tableEntry, int fileVersion) {
    CHUNKHEADER chunkHeader (fileVersion);
    string sourceFile;
    string fileDate;
    string author;
    local CHUNKTYPE chunkType = tableEntry.chunkType;
    local uint version = tableEntry.version;
    local uint offset = tableEntry.offset;
    local uint size = tableEntry.size;
};

struct EXPORTFLAGS(int fileVersion) {
    CHUNKHEADER chunkHeader(fileVersion);
    uint skipBytes;
    uint major;
    uint minor;
    uint build;
    uint revision;
    string rcVersionString;
};

struct DATASTREAMCHUNK(int fileVersion) {
    local int i;

    CHUNKHEADER headerInfo(fileVersion);
    if (headerInfo.version == 0x0800) {
        uint flags2;
        DATASTREAMTYPE datastreamType;
        uint numberOfElements;
        uint bytesPerElement;
        uint reserved1;
        uint reserved2;
        
        switch (datastreamType) {
            case VERTICES: {
                for (i = 0; i < numberOfElements; i++) {
                    VECTOR3 vertices <comment=PrintVector3>;
                }   
                break;
            }
            case VERTSUVS: {
                for (i = 0; i < numberOfElements; i++) {
                    VERTSUV vertsUvs(bytesPerElement);
                }
                break;
            }
            case NORMALS: {
                VECTOR3 normals[numberOfElements] <comment=PrintVector3>;
                break;
            }
            case UVS: {
                UV uv[numberOfElements] <comment=PrintUV>;
                break;   
            }
            case COLORS: {
                IRGBA colors[numberOfElements] <comment=PrintColor>;
                break;   
            }
            case INDICES: {
                uint16 indices[numberOfElements];
                break;   
            }
            case TANGENTS: {
                VECTOR4 tangent[numberOfElements];
                break;   
            }
            default: {
                break;
            }
        }
    }
    else if (headerInfo.version == 0x80000800) {
        BigEndian();
        uint flags2;
        DATASTREAMTYPE datastreamType;
        uint numberOfElements;
        uint bytesPerElement;
        uint reserved1;
        uint reserved2;
        switch (datastreamType) {
            case VERTICES: {
                for (i = 0; i < numberOfElements; i++) {
                    VECTOR3 vertices <comment=PrintVector3>;
                }   
                break;
            }
            case VERTSUVS: {
                for (i = 0; i < numberOfElements; i++) {
                    VERTSUV vertsUvs(bytesPerElement);
                }
                break;
            }
            case NORMALS: {
                VECTOR3 normals[numberOfElements] <comment=PrintVector3>;
                break;
            }
            case UVS: {
                UV uv[numberOfElements] <comment=PrintUV>;
                break;   
            }
            case COLORS: {
                IRGBA colors[numberOfElements] <comment=PrintColor>;
                break;   
            }
            case INDICES: {
                uint16 indices[numberOfElements];
                break;   
            }
            case TANGENTS: {
                VECTOR4 tangent[numberOfElements];
                break;   
            }
            default: {
                break;
            }
        }
        LittleEndian();
    };
};


#endif

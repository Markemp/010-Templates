//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: CryEngine-Structs
//   Authors: Geoff Gerber
//   Version: v0.1
//   Purpose: Structs used in Cryengine files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
#ifndef STRUCTS_COMMON_H
#define STRUCTS_COMMON_H

#include "Cryengine-BaseTypes.bt"

struct CHUNKHEADER(int fileVersion) {
    if (fileVersion == 0x0745) {
        CHUNKTYPE chunkType;
        uint version <format=hex>;
        uint offset <format=hex>;
        uint id <format=hex>;
    }
    else if (fileVersion == 0x0746) {
        // No chunk header in these.
    };
};

struct CONTROLLER_829 {
    uint controllerId;
    uint16 numberOfRotationKeys;
    uint16 numberOfPositionKeys;
    ubyte rotationFormat;
    ubyte rotationTimeFormat;
    ubyte positionFormat;
    ubyte positionKeyInfo;
    ubyte positionTimeFormat;
    ubyte tracksAligned;
};

struct CONTROLLER_905 {
    uint32 numKeyPos;
    uint32 numKeyRot;
    uint32 numKeyTime;
    uint32 numAnims;

    local uint i;
    // Key time lengths
    uint16 keyTime[numKeyTime];
    uint keyTimeFormat[7];
    uint16 keyPositionLength[numKeyPos];
    uint keyPositionFormat[9];
    uint16 keyRotationLength[numKeyRot];
    uint keyRotationFormat[9];
    uint keyTimeOffset[numKeyTime];
    uint keyPositionOffset[numKeyPos];
    uint keyRotationOffset[numKeyRot];
    uint trackLength;
};

struct VERTSUV(int bytesPerElement) {
    if (bytesPerElement == 16) {
        VECTOR3CRYHALF vertices <comment=PrintVector3CryHalf>;
        byte skip[2];
        IRGBA color <comment=PrintColor>;
        UVHALF uv <comment=PrintUVHalf>;
    }
    else if (bytesPerElement == 20) {
        VECTOR3 vertices <comment=PrintVector3>;
        IRGBA color <comment=PrintColor>;
        UV uv <comment=PrintUV>;
    };
};

struct BONEMAPDATA(int bytesPerElement) {
    if (bytesPerElement == 8) {
        byte boneIndex[4];
        byte weight[4];
    }
    else if (bytesPerElement == 12) {
        ushort boneIndex[4];
        byte weight[4];
    }
    else if (bytesPerElement == 24) {
        uint boneIndex[4];
        short weight[4];
    };
};

struct BONETOWORLD {
    float row1[4];
    float row2[4];
    float row3[4];
};

struct MTLNAME(int fileVersion) {
    CHUNKHEADER chunkHeader(fileVersion);
    MtlNameTypeEnum mtlType;
    int NFlags2;
    char Name[128];
    int PhysicalizeType;
    int NumberOfSubmaterials;
    int SubMaterialChunkID[32];
    int AdvancedDataChunkID;
    float Opacity;
    int reserved[32];
};

struct MESHCHUNK(int fileVersion) {
    CHUNKHEADER chunkHeader(fileVersion);
    uint Flags1;
    uint Flags2;
    uint NumVertices;
    uint NumIndices;
    //uint NumVertSubsets; // 801 format
    uint MeshSubsets;
    uint VerticesData <format=hex>;
    uint NumBuffs <format=hex>;
    uint NormalsData <format=hex>;
    uint UVsData <format=hex>;
    uint ColorsData <format=hex>;
    uint Colors2Data <format=hex>;
    uint IndicesData <format=hex>;
    uint TangentsData <format=hex>;
    uint ShCoeffsData <format=hex>;
    uint ShapeDeformationData <format=hex>;
    uint BoneMapData <format=hex>;
    uint FaceMapData <format=hex>;
    uint VertMatsData <format=hex>;
    //uint MeshPhysicsData <format=hex>; // 801 format
    uint VertsUVData <format=hex>;
    uint PhysicsData[4] <format=hex>;
    VECTOR3 MinBound <comment=PrintVector3>;
    VECTOR3 MaxBound <comment=PrintVector3>;
};

struct MESHSUBSET {
    uint firstVertex;
    uint numberOfVertices;
    uint firstIndex;
    uint numberOfIndices;
    uint material;
    float radius;
    VECTOR3 center <comment=PrintVector3>;
};

struct MESHSUBSETCHUNK {
    uint flags;
    uint numberOfMeshSubsets;
    byte skip[8];
    MESHSUBSET meshSubSet[numberOfMeshSubsets];
};

struct NODECHUNK(int fileVersion) {
    if (fileVersion == 0x0745) {
        CHUNKHEADER chunkHeader(fileVersion);
    }
    else if (fileVersion == 0x0746) {
    }; // no headers on these chunks
    char name[64];
    uint objectNodeId <format=hex>; // Mesh chunk ID
    uint parentNodeId <format=hex>; // Chunk ID of parent node
    uint numberOfChildren;
    uint materialId <format=hex>;
    uint skipBytes;                 // Obsolete info
    MATRIX4x4 transform <comment=PrintMatrix4x4>;   
    VECTOR3 position <comment=PrintVector3>;        // Obsolete
    QUATERNION rotation <comment=PrintQuaternion>;  // Obsolete
    VECTOR3 scale <comment=PrintVector3>;           // Obsolete
    int controllerPos <format=hex>;
    int rotationPos <format=hex>;
    int scalePos <format=hex>;
    int propertyStringLength <format=hex>;          // length of property string
};

struct CHUNKTABLEENTRY(uint ver) {
    if (ver == 0x0745) {
        CHUNKTYPE chunkType;
        uint version <format=hex>;  
        uint offset <format=hex>;
        uint id <format=hex>;
        uint size <format=hex>;
    }
    else if (ver == 0x0746) {
        CHUNKTYPE chunkType;
        ushort version <format=hex>;
        uint id <format=hex>;
        uint size <format=hex>;
        uint offset <format=hex>;
    }
    else if (ver == 0x0744) {
        CHUNKTYPE chunkType;
        uint version <format=hex>;  
        uint offset <format=hex>;
        uint id <format=hex>;
        uint size <format=hex> = 0;
    }
};

struct CHUNKTABLE(uint ver, int numChunks) {
    local uint i;
    for (i = 0; i < numChunks; i++) {
        CHUNKTABLEENTRY tableEntry(ver) <comment=PrintChunkTableType>;
    };
};

struct TIMINGINFO(int fileVersion) {
    if (fileVersion == 0x0745) {
        CHUNKHEADER chunkHeader (fileVersion);
    }
    else if (fileVersion == 0x0746) {
    }; // no headers on these chunks
    float secondsPerTick;
    int ticksPerFrame;
    char globalName[32];
    int globalRangeStart;
    int globalRangeEnd;
};

struct SOURCEINFO(CHUNKTABLEENTRY &tableEntry, int fileVersion) {
    CHUNKHEADER chunkHeader (fileVersion);
    string sourceFile;
    string fileDate;
    string author;
    local CHUNKTYPE chunkType = tableEntry.chunkType;
    local uint version = tableEntry.version;
    local uint offset = tableEntry.offset;
    local uint size = tableEntry.size;
};

struct EXPORTFLAGS(int fileVersion) {
    CHUNKHEADER chunkHeader(fileVersion);
    uint skipBytes;
    uint major;
    uint minor;
    uint build;
    uint revision;
    string rcVersionString;
};

struct DATASTREAMCHUNK(int fileVersion) {
    local int i;

    CHUNKHEADER headerInfo(fileVersion);
    if (fileVersion = 0x0746) {  // Cryengine 3.8
        uint flags2;
        DATASTREAMTYPE datastreamType;
        uint numberOfElements;
        ushort bytesPerElement;
        ushort unknown;
        
        switch (datastreamType) {
            case VERTICES: {
                uint flags[2];
                for (i = 0; i < numberOfElements; i++) {
                    VECTOR3 vertices <comment=PrintVector3>;
                }   
                break;
            }
            case VERTSUVS: {
                uint flags[2];
                for (i = 0; i < numberOfElements; i++) {
                    VERTSUV vertsUvs(bytesPerElement) <comment=PrintVertsUvs>;
                }
                break;
            }
            case NORMALS: {
                uint flags[2];
                VECTOR3 normals[numberOfElements] <comment=PrintVector3>;
                break;
            }
            case UVS: {
                uint flags[2];
                UV uv[numberOfElements] <comment=PrintUV>;
                break;   
            }
            case COLORS: {
                uint flags[2];
                IRGBA colors[numberOfElements] <comment=PrintColor>;
                break;   
            }
            case INDICES: {
                uint flags[2];
                uint16 indices[numberOfElements];
                break;   
            }
            case TANGENTS: {
                uint flags[2];
                VECTOR4SHORT tangent[numberOfElements];
                break;   
            }
            case BONEMAPS: {
                uint flags[2];
                BONEMAPDATA boneMap(bytesPerElement)[numberOfElements];
                break;
            }
            case QTANGENTS: {
                uint flags[2];
                QTANGENT qtangents[numberOfElements];
            }
            default: {
                break;
            }
        }
    }
    else {

        if (headerInfo.version == 0x0800) {
            uint flags2;
            DATASTREAMTYPE datastreamType;
            uint numberOfElements;
            uint bytesPerElement;
            uint reserved1;
            uint reserved2;
            
            switch (datastreamType) {
                case VERTICES: {
                    for (i = 0; i < numberOfElements; i++) {
                        VECTOR3 vertices <comment=PrintVector3>;
                    }   
                    break;
                }
                case VERTSUVS: {
                    for (i = 0; i < numberOfElements; i++) {
                        VERTSUV vertsUvs(bytesPerElement);
                    }
                    break;
                }
                case NORMALS: {
                    VECTOR3 normals[numberOfElements] <comment=PrintVector3>;
                    break;
                }
                case UVS: {
                    UV uv[numberOfElements] <comment=PrintUV>;
                    break;   
                }
                case COLORS: {
                    IRGBA colors[numberOfElements] <comment=PrintColor>;
                    break;   
                }
                case INDICES: {
                    uint16 indices[numberOfElements];
                    break;   
                }
                case TANGENTS: {
                    VECTOR4 tangent[numberOfElements];
                    break;   
                }
                default: {
                    break;
                }
            }
        }
        else if (headerInfo.version == 0x80000800) {
            BigEndian();
            uint flags2;
            DATASTREAMTYPE datastreamType;
            uint numberOfElements;
            uint bytesPerElement;
            uint reserved1;
            uint reserved2;
            switch (datastreamType) {
                case VERTICES: {
                    for (i = 0; i < numberOfElements; i++) {
                        VECTOR3 vertices <comment=PrintVector3>;
                    }   
                    break;
                }
                case VERTSUVS: {
                    for (i = 0; i < numberOfElements; i++) {
                        VERTSUV vertsUvs(bytesPerElement);
                    }
                    break;
                }
                case NORMALS: {
                    VECTOR3 normals[numberOfElements] <comment=PrintVector3>;
                    break;
                }
                case UVS: {
                    UV uv[numberOfElements] <comment=PrintUV>;
                    break;   
                }
                case COLORS: {
                    IRGBA colors[numberOfElements] <comment=PrintColor>;
                    break;   
                }
                case INDICES: {
                    uint16 indices[numberOfElements];
                    break;   
                }
                case TANGENTS: {
                    VECTOR4 tangent[numberOfElements];
                    break;   
                }
                default: {
                    break;
                }
            }
            LittleEndian();
        };
    };
};


#endif

//------------------------------------------------
//--- 010 Editor v13.0.2 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef STRUCTS_IVO_H
#define STRUCTS_IVO_H

#include "Cryengine-Common.bt"
#include "CryengineIvo-Enums.bt"

struct CHUNKTABLE {
    CHUNKTYPE chunkType <format=hex>;
    uint version <format=hex>;  
    uint64 offset <format=hex>;
};

struct MESHCHUNK {
    uint flags2;  // 4 = no normals datastream, 5 has normals datastream
    uint numberOfVertices;
    uint numberOfIndices;
    uint numberOfSubmeshes;
    uint unknown;
    VECTOR3 minBound <comment=PrintVector3>;
    VECTOR3 maxBound <comment=PrintVector3>;
    uint unknown2;
};

struct IVOINDICES(int numberOfIndices) {
    uint bytesPerElement;
    ushort indices[numberOfIndices];
    if (numberOfIndices % 2 == 1) {
        ushort filler;
    } else {
        uint filler;
        if (filler != 0) {
            FSeek(FTell() - 4);
        }
    }
};

struct IVOVERTSUVS(int numberOfVertices) {
    uint bytesPerElement;

    struct VERTUV {
        VECTOR3 vertex <comment=PrintVector3>;
        COLOR color <comment=PrintColor>;
        UVHalf uv <comment=PrintUVHalf>;
    };
    VERTUV vertUvs[numberOfVertices];
};

struct IVOVERTSUVS_CGF(int numberOfVertices) {
	uint bytesPerElement;

	struct IVOVertsUvs_CGF {
		VECTOR3SHORT vertices <comment=PrintVector3Short>;
		COLOR color <comment=PrintColor>;
		short unknown;
		UVHalf uv <comment=PrintUVHalf>;
	};

	IVOVertsUvs_CGF vertUvs[numberOfVertices];
	
	if(numberOfVertices % 2 == 1) {
		uint filler;
	}
};

struct IVOCOLORS(int numberOfVertices) {
    uint bytesPerElement;
    COLOR vertexColors[numberOfVertices] <comment=PrintColor>;
    if (numberOfVertices % 2 == 1) {
        uint filler;
    }
};

struct IVONORMAL {
    byte x;
    byte y;
    byte z;
    byte w;
};

struct IVONORMALS(int numberOfVertices) {
    uint bytesPerElement;
    IVONORMAL normals[numberOfVertices] <comment=PrintNormal>;
    if (numberOfVertices % 2 == 1) {
        uint filler;
    }
};

struct TANGENTS(int numberOfVertices) {
    uint bytesPerElement;
    for (i = 0; i < numberOfVertices; i++) {
        TANGENT_BYTE tangent <comment=PrintTangentByte>;
    };
    for (i = 0; i < numberOfVertices; i++) {
        TANGENT_BYTE bitangent <comment=PrintTangentByte>;
    };
};

struct IVOMESHSUBSET {
    uint matId;
    uint firstIndex;
    uint numIndices;
    uint firstVertex;
    uint unknown;
    uint numVertices;
    VECTOR3 center <comment=PrintVector3>;
    uint unknown0 <format=hex>;
    uint unknown1;
    uint unknown2;
};

struct BONENAME {
    string boneName ;
};

struct MTLNAME {
    char Name[128];
};

string PrintNormal(IVONORMAL &normal) {
    string result;
    local VECTOR3 norm;
    norm.x = (2 * (normal.x/127.0 * normal.z/127.0 + normal.y/127.0 * normal.w/127.0));
    norm.y = (2 * (normal.y/127.0 * normal.z/127.0 - normal.x/127.0 * normal.w/127.0));
    norm.z = (2 * (normal.z/127.0 * normal.z/127.0 + normal.w/127.0 * normal.w/127.0)) - 1;
    SPrintf(result, "%f, %f, %f", norm.x, norm.y, norm.z);
    return result;
};

struct BONE {
    uint controllerId;
    uint limbId;
    int parentIndex;
    QUATERION relativeQuat <comment=GetQuaterion>;
    VECTOR3 relativeTransform <comment=PrintVector3>;     // relative x,y,z from parent
    QUATERION worldQuat <comment=GetQuaterion>;
    VECTOR3 worldTransform <comment=PrintVector3>;        // absolute x,y,z from origin
};

struct BONEIDS_x901 {
	uint controllerId;
	uint uVal1; // I haven't a damn clue what this is, it may be a uint id, it may be some kind of referencing with two shorts. 
	short uParentIndex;
	short uVal3;
	short numberOfVertices; // Seems to be two shorts that are always -1 in the files I've seen
	short uBoneIndex; // Seems to be an indicator of location within a larger set of bones? Ordered by parent, then iterative by this value
};

struct BONETRANSFORMS_x901 {
	QUATERION relativeQuat <comment=GetQuaterion>;
	VECTOR3 relativeTransform <comment=PrintVector3>; // relative x,y,z from parent
	QUATERION worldQuat <comment=GetQuaterion>;
	VECTOR3 worldTransform <comment=PrintVector3>; // absolute x,y,z from origin
};

struct COMPILEDBONES {
    uint numberOfBones;
    local int i;
    for (i = 0; i < numberOfBones; i++) {
        BONE bone <comment=PrintBoneInfo>;
    };
    for (i = 0; i < numberOfBones; i++) {
        BONENAME boneName <comment=GetBoneName>;
    };
};

struct COMPILEDPHYSICALBONES {
    char physics[100];
};



string PrintBoneInfo(BONE &bone) {
    string result;
    SPrintf(result, "Relative X, Y, Z: %f, %f, %f, World X, Y, Z: %f, %f, %f", bone.relativeTransform.x, bone.relativeTransform.y, bone.relativeTransform.z, bone.worldTransform.x, bone.worldTransform.y, bone.worldTransform.z);
    return result;
}

#endif
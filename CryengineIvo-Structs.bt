//------------------------------------------------
//--- 010 Editor v13.0.2 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#ifndef STRUCTS_IVO_H
#define STRUCTS_IVO_H

#include "Cryengine-BaseTypes.bt"
#include "CryengineIvo-Enums.bt"

struct HEADER {
    char fileSig[4];
    uint version;
    uint numChunks;
    int offset;  // location of header chunks
};

struct CHUNKTABLEENTRY {
    CHUNKTYPE chunkType <format=hex>;
    uint version <format=hex>;  
    uint64 offset <format=hex>;
};

struct CHUNKTABLE(int numberOfChunks) {
    local uint i;
    for (i = 0; i < numberOfChunks; i++) {
        CHUNKTABLEENTRY tableEntry <comment=PrintChunkTableType>;
    };
};

struct MESHCHUNK {
    uint flags2;  // 4 = no normals datastream, 5 has normals datastream
    uint numberOfVertices;
    uint numberOfIndices;
    uint numberOfSubmeshes;
    uint unknown;
    VECTOR3 minBound <comment=PrintVector3>;
    VECTOR3 maxBound <comment=PrintVector3>;
    uint unknown2;
};

struct IVOINDICES(int numberOfIndices) {
    uint bytesPerElement;
    ushort indices[numberOfIndices];
    if (numberOfIndices % 2 == 1) {
        ushort filler;
    } else {
        uint filler;
        if (filler != 0) {
            FSeek(FTell() - 4);
        }
    }
};

struct IVOVERTSUVS(int numberOfVertices) {
    uint bytesPerElement;

    struct VERTUV {
        VECTOR3 vertex <comment=PrintVector3>;
        COLOR color <comment=PrintColor>;
        UVHALF uv <comment=PrintUVHalf>;
    };
    VERTUV vertUvs[numberOfVertices];
};

struct IVOVERTSUVS_CGF(int numberOfVertices) {
	uint bytesPerElement;

	struct IVOVertsUvs_CGF {
		VECTOR3SHORT vertices <comment=PrintVector3Short>;
		COLOR color <comment=PrintColor>;
		short unknown;
		UVHALF uv <comment=PrintUVHalf>;
	};

	IVOVertsUvs_CGF vertUvs[numberOfVertices];
	
	if(numberOfVertices % 2 == 1) {
		uint filler;
	}
};

struct IVOCOLORS(int numberOfVertices) {
    uint bytesPerElement;
    COLOR vertexColors[numberOfVertices] <comment=PrintColor>;
    if (numberOfVertices % 2 == 1) {
        uint filler;
    }
};

struct IVONORMAL {
    byte x;
    byte y;
    byte z;
    byte w;
};

struct IVONORMALS(int numberOfVertices) {
    uint bytesPerElement;
    IVONORMAL normals[numberOfVertices] <comment=PrintNormal>;
    if (numberOfVertices % 2 == 1) {
        uint filler;
    }
};

struct TANGENTS(int numberOfVertices) {
    uint bytesPerElement;
    for (i = 0; i < numberOfVertices; i++) {
        TANGENT_BYTE tangent <comment=PrintTangentByte>;
    };
    for (i = 0; i < numberOfVertices; i++) {
        TANGENT_BYTE bitangent <comment=PrintTangentByte>;
    };
};

struct IVOMESHSUBSET {
    ushort matId;
    ushort submeshParent;
    uint firstIndex;
    uint numIndices;
    uint firstVertex;
    uint unknown;
    uint numVertices;
    VECTOR3 center <comment=PrintVector3>;
    uint unknown0 <format=hex>;
    uint unknown1;
    uint unknown2;
};

struct BONENAME {
    string boneName ;
};

struct MTLNAME {
    char Name[128];
};

struct BONETOWORLD {
    float row1[4];
    float row2[4];
    float row3[4];
};

struct BONE {
    uint controllerId;
    uint limbId;
    int parentIndex;
    QUATERNION relativeQuat <comment=GetQuaterion>;
    VECTOR3 relativeTransform <comment=PrintVector3>;     // relative x,y,z from parent
    QUATERNION worldQuat <comment=GetQuaterion>;
    VECTOR3 worldTransform <comment=PrintVector3>;        // absolute x,y,z from origin
};

struct BONEIDS_x901 {
	uint controllerId;
	uint uVal1; // I haven't a damn clue what this is, it may be a uint id, it may be some kind of referencing with two shorts. 
	short uParentIndex;
	short uVal3;
	short numberOfVertices; // Seems to be two shorts that are always -1 in the files I've seen
	short uBoneIndex; // Seems to be an indicator of location within a larger set of bones? Ordered by parent, then iterative by this value
};

struct BONETRANSFORMS_x901 {
	QUATERNION relativeQuat <comment=GetQuaterion>;
	VECTOR3 relativeTransform <comment=PrintVector3>; // relative x,y,z from parent
	QUATERNION worldQuat <comment=GetQuaterion>;
	VECTOR3 worldTransform <comment=PrintVector3>; // absolute x,y,z from origin
};

struct COMPILEDBONES {
    uint numberOfBones;
    local int i;
    for (i = 0; i < numberOfBones; i++) {
        BONE bone <comment=PrintBoneInfo>;
    };
    for (i = 0; i < numberOfBones; i++) {
        BONENAME boneName <comment=GetBoneName>;
    };
};

struct COMPILEDPHYSICALBONES {
    char physics[100];
};

struct LODDISTANCE_x900 {
    uint unknown;
    VECTOR3 unkBound1 <comment=PrintVector3>;
    VECTOR3 unkBound2 <comment=PrintVector3>;    
};

struct STATOBJ_PHYSICS_x900 {
    // The following values are indexes used in pointer math that are multiplied by 2
    // which is the size of the following values being read in the chunk.
    uint base_iter; // Base of the chunk/iteration table
    uint unk_iter1;
    uint unk_iter2;
    uint unk_iter3;
    uint unk_iter4;
    uint unk_iter5;
    uint unk_iter6;
    uint unk_iter7;
    uint unk_iter8;
    uint unk_iter9;
    uint end_iter; // Chunk parser attempts to parse this first
    
    uint unk_val1;
    uint unk_val2;
    
    struct PHYS_VECS {
        ushort index1;
        ushort unk;
        uint unk1;
    };
    
    // Needs more work as this is obviously misaligned.
    // Probably misreading disassembly
    PHYS_VECS base_vec[base_iter*2];
    PHYS_VECS unk1_vec[unk_iter1*2];
    PHYS_VECS unk2_vec[unk_iter2*2];
    PHYS_VECS unk3_vec[unk_iter3*2];
    PHYS_VECS unk4_vec[unk_iter4*2];
    PHYS_VECS unk5_vec[unk_iter5*2];
    PHYS_VECS unk6_vec[unk_iter6*2];
    PHYS_VECS unk7_vec[unk_iter7*2];
    PHYS_VECS unk8_vec[unk_iter8*2];
    PHYS_VECS unk9_vec[unk_iter9*2];
    PHYS_VECS end_vec[end_iter*2];
};

struct BBOX {
    VECTOR3 min <comment=PrintVector3>;
    VECTOR3 max <comment=PrintVector3>;  
};

struct SUBOBJ_x900 {
    uint ZeroPad;
    uint NumSubObjs; // Same as number of bones?
    uint RootNode;
    uint NumBoneIndices;
    uint NumSubmeshes;
    uint SNodeStrTable;
    uint SNodeProperties;
    uint UnkVal2;
    
    // Struct must be 208 bytes
    struct SUBOBJCHUNK {
        MATRIX3x4 TransMat1 <comment=PrintMat3x4Trans>;
        MATRIX3x4 TransMat2 <comment=PrintMat3x4Trans>;
        VECTOR3 HelperPos <comment=PrintVector3>; // Appears the be the same values previously in the helper chunk "pos" vector, but divided by 100? Clearly not a pos vector besides that.
        uint unkVal <format=hex>; // No idea
        ushort childIndex1; // So the following two appear to be the relative "child" index from the parent node.
        ushort childIndex2; // I have no idea why they're duplicated though.
        ushort parentIndex; // Parent index, 0xFF if root node.
        ushort unkShort <format=hex>; // appears to generally be 0x3?
        BBOX BoundingBox;
        uint unkVals[5];
        ushort numChildren;
        ushort flag <format=hex>;
        ubyte unk2[40];
    };
    
    struct NodeString {
        string AttachPoint;
    };
    
    // This may be cursed, but I also may not care.
    // The warnings do not matter, and this is necessary to make the individual values readable.
    typedef struct (string s) {
        local string str = s;
    } StringWrapper <read=(str)>;
        
    typedef struct {
        string source <hidden=true>;
        
        // Is the following disgusting? Yes.
        // Does it make the template results nicer to look at? Also yes.
        
        local string prevStr = source;
        local uint feqi = Strstr(prevStr, "=");
        local string nextStr = StrDel(prevStr, 0, feqi+1);
        local uint feqn = Strstr(nextStr, "\n"); // find next after first
        
        StringWrapper node(SubStr(prevStr, feqi+1, feqn));
        
        prevStr = nextStr;
        feqi = Strstr(prevStr, "=");
        nextStr = StrDel(prevStr, 0, feqi+1);
        feqn = Strstr(nextStr, "\n"); // find next after first
        
        StringWrapper class(SubStr(prevStr, feqi+1, feqn));
        
        prevStr = nextStr;
        feqi = Strstr(prevStr, "=");
        nextStr = StrDel(prevStr, 0, feqi+1);
        feqn = Strstr(nextStr, "\n"); // find next after first
        
        StringWrapper detach(SubStr(prevStr, feqi+1, feqn));
    } NodeProperties;
        
    SUBOBJCHUNK SubObjChunk[NumSubObjs]; // A few 3x4 matrices at least per bone
    ushort BonesIndices[NumBoneIndices]; // No idea, but appears to be similar to submeshes
    ushort SubmeshesIndices[NumSubmeshes]; // hierarchy information?
    NodeString NodeStrTable[NumSubObjs] <read=(AttachPoint), optimize=false>; // Attachment point string table!
    // Unserialized node properties with newline separator?
    // Appears to contain following properties per node:
    // node=<>\nclass=<>\ndetach=<>
    // Most commonly takes the form of:
    // node=Part\nclass=ItemPort\ndetach=False
    NodeProperties NodePropertiesStrTable[NumSubObjs] <optimize=false>;
};


struct SKINMESH {
    local ulong position;

    uint flags;
    MESHCHUNK meshChunk;
    char unknown2[116] <fgcolor=cAqua>;
    IVOMESHSUBSET meshSubsets[meshChunk.numberOfSubmeshes];
    while (!FEof()) {
        position = FTell();
        DatastreamType type;
        while (!isInEnum(type)) {
            if (FEof()) {
                break; // Exit if we reached the end of the file
            }
            DatastreamType type;
        }
        
        // Ensure no further processing if we break due to EOF
        if (FEof()) {
            break; // Stop processing if we've reached the end
        }
        switch (type) {
            case IvoVertsUvs: {
                IVOVERTSUVS vertsUvs(meshChunk.numberOfVertices) <bgcolor=cLtBlue>;
                break;
            }
            case IvoVertsUvsCGF: {
                IVOVERTSUVS_CGF vertsUvs(meshChunk.numberOfVertices) <bgcolor=cLtBlue>;
                break;
            }
            case IvoIndices: {
                IVOINDICES indices(meshChunk.numberOfIndices) <bgcolor=cDkBlue>;
                break;
            }
            case IvoNormals: {
                IVONORMALS normals(meshChunk.numberOfVertices) <bgcolor=cBlue>;
                break;
            }
            case IvoNormals2: {
                IVONORMALS normals(meshChunk.numberOfVertices) <bgcolor=cLtBlue>;
                break;
            }    
            case IvoColors2: {
                IVOCOLORS colors2(meshChunk.numberOfVertices) <bgcolor=cBlue>;
                break;
            }
            case IvoTangents: {
                TANGENTS tangents(meshChunk.numberOfVertices) <bgcolor=cDkBlue>;
                break;
            }
            case IvoBoneMap: {
                //BONEMAP bonemap(meshChunk.numberOfVertices) <bgcolor=cLtBlue>;
                break;
            }
            case IvoBoneMap32: {
                //BONEMAP32 bonemap(meshChunk.numberOfVertices) <bgcolor=cBlue>;
                break;
            }
            case U3_LODDistance: {
                LODDISTANCE_x900 LODDistance <bgcolor=cLtBlue>;
                break;
            };
            case U6_StatObj_Physics: {
                STATOBJ_PHYSICS_x900 StaticObj_Phys <bgcolor=cLtGreen>;
                break;
            };
            case U5_SubObjs: {
                SUBOBJ_x900 SubObj <bgcolor=cLtRed>;
                break;
            };
        }
    };
};

#endif
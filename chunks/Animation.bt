//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: Animation.bt
//   Authors: Geoff Gerber
//   Purpose: Animation structures for all CryEngine formats
//            Includes CAF/DBA support for Star Citizen Ivo format
//------------------------------------------------

#ifndef CHUNKS_ANIMATION_BT
#define CHUNKS_ANIMATION_BT

#include "core/BaseTypes.bt"
#include "core/Enums.bt"
#include "core/Utilities.bt"
#include "display/PrintFunctions.bt"
#include "chunks/Header.bt"

//===========================================
// CryTek/CrChF Animation Structures
//===========================================

//------------------------------------------------
// Key Times Format Counts
// Stores count of tracks using each format type
//------------------------------------------------

struct KeyTimesFormatCounts {
    uint32 eF32;
    uint32 eUINT16;
    uint32 eByte;
    uint32 eF32StartStop;
    uint32 eUINT16StartStop;
    uint32 eByteStartStop;
    uint32 eBitset;
};

//------------------------------------------------
// Motion Parameters (v0905)
//------------------------------------------------

struct MotionParams905 {
    uint32 assetFlags;
    uint32 compression;
    int32 ticksPerFrame;
    float secsPerTick;
    int32 start;
    int32 end;
    float moveSpeed;
    float turnSpeed;
    float assetTurn;
    float distance;
    float slope;
    QuatT startLocation <comment=PrintQuatT>;
    QuatT endLocation <comment=PrintQuatT>;
    float lHeelStart;
    float lHeelEnd;
    float lToe0Start;
    float lToe0End;
    float rHeelStart;
    float rHeelEnd;
    float rToe0Start;
    float rToe0End;
};

//------------------------------------------------
// Controller Info (v0905)
//------------------------------------------------

struct CControllerInfo {
    uint32 controllerID;
    int32 posKeyTimeTrack;
    int32 posTrack;
    int32 rotKeyTimeTrack;
    int32 rotTrack;
};

//------------------------------------------------
// Animation Entry (v0905)
//------------------------------------------------

struct AnimationEntry(int isInPlaceStream) {
    uint16 filePathLength;
    if (filePathLength > 0) {
        char filePath[filePathLength];
    }
    MotionParams905 motionParams;
    uint16 footPlantBitsCount;
    if (footPlantBitsCount > 0) {
        ubyte footPlantBits[footPlantBitsCount];
    }
    uint16 controllerCount;
    if (isInPlaceStream) {
        // In-place streaming: controllers are in separate block, just store offset
        int32 offsetToControllerHeaders;
    } else {
        // Standard: controllers inline
        if (controllerCount > 0) {
            CControllerInfo controllers[controllerCount];
        }
    }
};

string PrintAnimationEntry(AnimationEntry &entry) {
    if (exists(entry.filePath)) {
        return entry.filePath;
    }
    return "<no path>";
}

//------------------------------------------------
// Controller Chunk Desc (v0905)
//------------------------------------------------

struct ControllerChunkDesc905 {
    uint32 numKeyPos;
    uint32 numKeyRot;
    uint32 numKeyTime;
    uint32 numAnims;
};

string PrintControllerChunkDesc905(ControllerChunkDesc905 &desc) {
    string result;
    SPrintf(result, "Pos:%d Rot:%d Time:%d Anims:%d",
        desc.numKeyPos, desc.numKeyRot, desc.numKeyTime, desc.numAnims);
    return result;
}

//------------------------------------------------
// Controller v0829 - CryTek/CrChF format
//------------------------------------------------

struct Controller829_Cry(FileFormat format) {
    ChunkHeader chunkHeader(format);

    uint controllerId;
    uint16 numRotationKeys;
    uint16 numPositionKeys;
    ECompressionFormat rotationFormat;
    EKeyTimesFormat rotationTimeFormat;
    ECompressionFormat positionFormat;
    ubyte positionKeyInfo;
    EKeyTimesFormat positionTimeFormat;
    ubyte tracksAligned;
    ushort padding;
   
    // Rotation Data
    if (numRotationKeys > 0) {
        switch (rotationFormat) {
            case eNoCompress:
            case eNoCompressQuat:
                NoCompressQuat rotationKeys[numRotationKeys];
                break;
            case eSmallTree48BitQuat:
                SmallTree48BitQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree48BitQuat>;
                break;
            case eSmallTree64BitQuat:
                SmallTree64BitQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree64BitQuat>;
                break;
            case eSmallTree64BitExtQuat:
                SmallTree64BitExtQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree64BitExtQuat>;
                break;
            default:
                ubyte rotationData[numRotationKeys * GetRotationSize(rotationFormat)];
                break;
        }

        if (tracksAligned != 0) {
            local int pos = FTell();
            local int padding = (4 - (pos % 4)) % 4;
            if (padding > 0) {
                ubyte rotationValuePadding[padding];
            }
        }

        switch (rotationTimeFormat) {
            case eF32:
            case eF32StartStop:
                F32KeyTime rotationTimes[numRotationKeys];
                break;
            case eUINT16:
            case eUINT16StartStop:
            case eBitset:
                Uint16KeyTime rotationTimes[numRotationKeys];
                break;
            case eByte:
            case eByteStartStop:
                ByteKeyTime rotationTimes[numRotationKeys] <comment=PrintByteKeyTime>;
                break;
            default:
                ubyte rotationTimeData[numRotationKeys * GetTimeKeySize(rotationTimeFormat)];
                break;
        }

        if (tracksAligned != 0) {
            local int pos = FTell();
            local int padding = (4 - (pos % 4)) % 4;
            if (padding > 0) {
                ubyte rotationTimePadding[padding];
            }
        }
    }

    // Position Data
    if (numPositionKeys > 0) {
        switch (positionFormat) {
            case eNoCompress:
            case eNoCompressVec3:
                Vector3 positionKeys[numPositionKeys] <comment=PrintVector3>;
                break;
            default:
                ubyte positionData[numPositionKeys * GetPositionSize(positionFormat)];
                break;
        }

        if (tracksAligned != 0) {
            local int pos = FTell();
            local int padding = (4 - (pos % 4)) % 4;
            if (padding > 0) {
                ubyte positionValuePadding[padding];
            }
        }

        if (positionKeyInfo != 0) {
            switch (positionTimeFormat) {
                case eF32:
                case eF32StartStop:
                    F32KeyTime positionTimes[numPositionKeys];
                    break;
                case eUINT16:
                case eUINT16StartStop:
                case eBitset:
                    Uint16KeyTime positionTimes[numPositionKeys];
                    break;
                case eByte:
                case eByteStartStop:
                    ByteKeyTime positionTimes[numPositionKeys] <comment=PrintByteKeyTime>;
                    break;
                default:
                    ubyte positionTimeData[numPositionKeys * GetTimeKeySize(positionTimeFormat)];
                    break;
            }

            if (tracksAligned != 0) {
                local int pos = FTell();
                local int padding = (4 - (pos % 4)) % 4;
                if (padding > 0) {
                    ubyte positionTimePadding[padding];
                }
            }
        }
    }
};

//------------------------------------------------
// Controller v0905 - CryTek/CrChF format
//------------------------------------------------

struct Controller905_Cry(FileFormat format) {
    ChunkHeader chunkHeader(format);

    ControllerChunkDesc905 header <comment=PrintControllerChunkDesc905>;

    // Size/format block
    // Note: Format is stored as count structures (counts per format type),
    // not as per-track format values
    uint16 keyTimeSizes[header.numKeyTime];
    KeyTimesFormatCounts keyTimeFormatCounts;
    uint16 positionSizes[header.numKeyPos];
    CompressionFormatCounts positionFormatCounts;
    uint16 rotationSizes[header.numKeyRot];
    CompressionFormatCounts rotationFormatCounts;

    // Offset arrays (+1 for end marker on rotation offsets)
    int32 keyTimeOffsets[header.numKeyTime];
    int32 positionOffsets[header.numKeyPos];
    int32 rotationOffsets[header.numKeyRot + 1];

    // Detect in-place streaming mode (negative offsets)
    local int isInPlaceStream = (header.numKeyTime > 0 && keyTimeOffsets[0] < 0);
    if (isInPlaceStream) {
        uint32 paddingLength;
        if (paddingLength > 0) {
            ubyte streamPadding[paddingLength];
        }
    }

    // Align to 4 bytes after size/offset block
    AlignTo4();

    // Track data size from terminator offset
    local int trackDataSize = 0;
    if (header.numKeyRot > 0) {
        trackDataSize = isInPlaceStream ? -rotationOffsets[header.numKeyRot] : rotationOffsets[header.numKeyRot];
    }

    // Non-in-place streaming: track data comes before animation entries
    if (!isInPlaceStream && trackDataSize > 0) {
        ubyte trackData[trackDataSize];
    }

    // Animation entries
    struct {
        local int i;
        for (i = 0; i < header.numAnims; i++) {
            AnimationEntry animation(isInPlaceStream) <comment=PrintAnimationEntry>;
        }
    } animations;

    // In-place streaming: controller headers and track data after animation entries
    if (isInPlaceStream) {
        // Calculate total controllers from all animation entries
        local int totalControllers = 0;
        local int j;
        for (j = 0; j < header.numAnims; j++) {
            totalControllers += animations.animation[j].controllerCount;
        }
        if (totalControllers > 0) {
            CControllerInfo controllerBlock[totalControllers];
        }

        // Track data is at the very end for in-place streaming
        AlignTo4();
        if (trackDataSize > 0) {
            ubyte trackData[trackDataSize];
        }
    }
};

//===========================================
// Ivo Animation Structures (CAF/DBA)
//===========================================

//------------------------------------------------
// Animation Info Chunk (CAF files, Version 0x0901)
// Contains metadata about the animation
//------------------------------------------------

struct AnimInfoChunk_Ivo {
    uint32 flags;                    // Animation flags (0=normal, 2=pose?)
    uint16 framesPerSecond;          // FPS - typically 30
    uint16 numBones;                 // Number of animated bones
    uint32 unknown2;                 // Reserved
    uint32 numPositionTracks;        // Number of bones with position animation
    float boundMin[3];               // Bounding box minimum (often 0,0,0)
    float scale;                     // Scale factor (typically ~1.0)
    double precision;                // Precision value for compression
    uint32 padding[2];               // Reserved padding
};

string PrintAnimInfo_Ivo(AnimInfoChunk_Ivo &info) {
    string result;
    SPrintf(result, "Flags:%d FPS:%d Bones:%d PosTracks:%d Scale:%.4f",
        info.flags, info.framesPerSecond, info.numBones, info.numPositionTracks, info.scale);
    return result;
}

//------------------------------------------------
// Controller Entry (shared by #caf and #dba)
// 24 bytes total - contains rotation and optional position track info
// Offsets are relative to the start of the keyframe data section
//------------------------------------------------

// Format flags for rotation/position tracks
// 0x8040 = rotation track present
// 0xC040 = position track present (bit 14 = 0x4000)
// Bit 6 (0x0040) and bit 15 (0x8000) appear always set for valid tracks

// Time header structure (8 bytes) - appears before time/data blocks
struct AnimTimeHeader_Ivo {
    uint16 startTime;              // Start time (usually 0)
    uint16 endTime;                // End time (e.g., 0x1E = 30)
    uint32 marker;                 // Marker value (0x7FFFFFFF, 0x5FFFFFFF, etc.)
};

string PrintAnimTimeHeader_Ivo(AnimTimeHeader_Ivo &h) {
    string result;
    SPrintf(result, "time: %d-%d, marker=0x%08X", h.startTime, h.endTime, h.marker);
    return result;
}

// Controller entry structure (24 bytes) - used by DBA blocks
struct AnimControllerEntry_Ivo {
    uint16 numRotKeys;
    uint16 rotFormatFlags;
    uint32 rotTimeOffset;
    uint32 rotDataOffset;
    uint16 numPosKeys;
    uint16 posFormatFlags;
    uint32 posTimeOffset;
    uint32 posDataOffset;
};

string PrintControllerEntry_Ivo(AnimControllerEntry_Ivo &ctrl) {
    string result;
    local int hasPos = (ctrl.posFormatFlags != 0);
    local int rotGap = ctrl.rotDataOffset - ctrl.rotTimeOffset;
    if (hasPos) {
        local int posGap = ctrl.posDataOffset - ctrl.posTimeOffset;
        SPrintf(result, "Rot:%dkeys @time=0x%X @data=0x%X (gap=%d) flags=0x%04X | Pos:%dkeys @time=0x%X @data=0x%X (gap=%d) flags=0x%04X",
            ctrl.numRotKeys, ctrl.rotTimeOffset, ctrl.rotDataOffset, rotGap, ctrl.rotFormatFlags,
            ctrl.numPosKeys, ctrl.posTimeOffset, ctrl.posDataOffset, posGap, ctrl.posFormatFlags);
    } else {
        SPrintf(result, "Rot:%dkeys @time=0x%X @data=0x%X (gap=%d) flags=0x%04X",
            ctrl.numRotKeys, ctrl.rotTimeOffset, ctrl.rotDataOffset, rotGap, ctrl.rotFormatFlags);
    }
    return result;
}

//------------------------------------------------
// Animation Block Header (12 bytes)
//------------------------------------------------

struct AnimBlockHeader_Ivo {
    char signature[4];
    uint16 boneCount;              // Number of bones (up to 1024 in CryEngine)
    uint16 magic;
    uint32 chunkSize;
};

string PrintAnimBlockHeader_Ivo(AnimBlockHeader_Ivo &hdr) {
    string result;
    SPrintf(result, "%c%c%c%c Bones: %d, Magic: 0x%04X, Size: %d",
        hdr.signature[0], hdr.signature[1], hdr.signature[2], hdr.signature[3],
        hdr.boneCount, hdr.magic, hdr.chunkSize);
    return result;
}

//------------------------------------------------
// Keyframe Data Structures for Ivo CAF
//------------------------------------------------

// Per-bone data header (8 bytes) - appears before each bone's rotation data
struct BoneDataHeader_Ivo {
    uint16 padding;           // Usually 0
    uint16 value;             // Often 0x1E (30) - possibly key count or frame count
    uint32 marker;            // 0x7FFFFFFF or 0x5FFFFFFF - sentinel/marker
};

string PrintBoneDataHeader_Ivo(BoneDataHeader_Ivo &h) {
    string result;
    SPrintf(result, "value=%d marker=0x%08X", h.value, h.marker);
    return result;
}

// Uncompressed quaternion (16 bytes) - used in Ivo CAF
struct UncompressedQuat_Ivo {
    float x;
    float y;
    float z;
    float w;
};

string PrintUncompressedQuat_Ivo(UncompressedQuat_Ivo &q) {
    string result;
    local float mag = Sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
    local string normStr = (mag > 0.98 && mag < 1.02) ? " [OK]" : " [BAD]";
    SPrintf(result, "(%.4f, %.4f, %.4f, %.4f) mag=%.4f%s", q.x, q.y, q.z, q.w, mag, normStr);
    return result;
}

// Bone rotation track - header + quaternions
struct BoneRotationTrack_Ivo(int numKeys) {
    BoneDataHeader_Ivo header <bgcolor=cDkGray, comment=PrintBoneDataHeader_Ivo>;
    if (numKeys > 0) {
        UncompressedQuat_Ivo rotations[numKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
    }
};

//------------------------------------------------
// CAF Chunk (single animation)
// Contains bone hashes, controller entries, and keyframe data
// Animation data is read using offsets from the start of the controllers array
//------------------------------------------------

struct CAFChunk_Ivo {
    AnimBlockHeader_Ivo header <bgcolor=cLtBlue, comment=PrintAnimBlockHeader_Ivo>;

    local int numBones = header.boneCount;
    local int64 blockStart = FTell() - 12;
    local int64 blockEnd = blockStart + header.chunkSize;

    // Bone identification - CRC32 hashes matching skeleton bones
    uint32 boneHashes[numBones] <bgcolor=cLtGreen, comment="CRC32 bone identifiers">;

    // Mark the start of controllers - all offsets are relative to this position
    local int64 controllersStart = FTell();

    // Read each controller with its associated animation data
    local int b;
    for (b = 0; b < numBones; b++) {
        struct AnimController_Ivo {
            // Track start of this controller - offsets are relative to here
            local int64 controllerStart = FTell();

            // Controller header (24 bytes)
            uint16 numRotKeys;
            uint16 rotFormatFlags;
            uint32 rotTimeOffset;
            uint32 rotDataOffset;
            uint16 numPosKeys;
            uint16 posFormatFlags;
            uint32 posTimeOffset;
            uint32 posDataOffset;

            // Save position after reading controller header
            local int64 savedPos = FTell();

            // Read rotation time and data if present
            // Format flags: 0x8040 = ubyte time array, 0x8042 = uint16 time with 8-byte header
            if (numRotKeys > 0 && rotTimeOffset > 0) {
                FSeek(controllerStart + rotTimeOffset);
                local ubyte rotFormat = rotFormatFlags & 0x0F;  // Low nibble: 0=ubyte time, 2=uint16 time

                if (rotFormat == 0x00) {
                    // 0x8040: ubyte time array (padded to 4-byte boundary)
                    ubyte rotTimeData[numRotKeys] <bgcolor=cDkGray, comment="Rotation time keys (ubyte)">;
                } else {
                    // 0x8042: 8-byte time header (startTime, endTime, marker)
                    AnimTimeHeader_Ivo rotTimeHeader <bgcolor=cDkGray, comment=PrintAnimTimeHeader_Ivo>;
                }

                FSeek(controllerStart + rotDataOffset);
                UncompressedQuat_Ivo rotations[numRotKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
            }

            // Read position time and data if present
            if (numPosKeys > 0 && posFormatFlags != 0) {
                // Time and position data are at separate locations (not adjacent)
                // Flag breakdown:
                //   0xC040: ubyte time (4 bytes), no header, numPosKeys positions
                //   0xC142: uint16 time + marker (8 bytes), no header, 2 positions
                //   0xC242: uint16 time + marker (8 bytes), 8-byte header, 1 position
                local ubyte posFormat = posFormatFlags & 0x0F;         // Low nibble: 0=ubyte time, 2=uint16 time
                local ubyte posVariant = (posFormatFlags >> 8) & 0x0F; // 0, 1, or 2

                // Read position time data
                FSeek(controllerStart + posTimeOffset);

                // 0x40 (low nibble 0) = ubyte time, 0x42 (low nibble 2) = uint16 time
                if (posFormat == 0x00) {
                    // ubyte time format (4 bytes for numPosKeys times)
                    ubyte posTimeData[numPosKeys] <bgcolor=cDkGray, comment="Position time keys (ubyte)">;
                } else {
                    // uint16 time format with marker (8 bytes total)
                    struct PosTimeBlock {
                        uint16 timeStart;
                        uint16 timeEnd;
                        uint32 marker;
                    } posTimeData <bgcolor=cDkGray, comment=Str("time: %d-%d, marker=0x%08X", this.timeStart, this.timeEnd, this.marker)>;
                }

                // Read position data (separate location)
                FSeek(controllerStart + posDataOffset);

                // Position format based on variant (middle nibble):
                // variant=0 (0xC040): no header, numPosKeys positions
                // variant=1 (0xC142): no header, 2 positions
                // variant=2 (0xC242): 8-byte header, 1 position
                if (posVariant == 0) {
                    // 0xC040: No header, use numPosKeys as count
                    Vector3 positions[numPosKeys] <bgcolor=cLtGreen, comment=PrintVector3>;
                } else if (posVariant == 1) {
                    // 0xC142: No header, 2 positions
                    Vector3 positions[2] <bgcolor=cLtGreen, comment=PrintVector3>;
                } else if (posVariant == 2) {
                    // 0xC242: 8-byte header, 1 position
                    struct PosDataBlock {
                        ubyte posHeader[8] <bgcolor=cDkGray, comment="Position data header">;
                        Vector3 positions[1] <bgcolor=cLtGreen, comment=PrintVector3>;
                    } posData;
                } else {
                    // Unknown format - read as raw bytes
                    ubyte posDataRaw[24] <bgcolor=cRed, comment="Unknown position format">;
                }
            }

            // Restore position for next controller
            FSeek(savedPos);
        } controller <bgcolor=cLtYellow,
                      comment=Str("Rot=%d keys (flags=0x%04X), Pos=%d keys (flags=0x%04X)", this.numRotKeys, this.rotFormatFlags, this.numPosKeys, this.posFormatFlags)>;
    }

    // Seek to end of block
    FSeek(blockEnd);
};

string PrintCAFChunk_Ivo(CAFChunk_Ivo &caf) {
    string result;
    local int posCount = 0;
    local int i;
    for (i = 0; i < caf.numBones; i++) {
        if (caf.controller[i].posFormatFlags != 0) {
            posCount++;
        }
    }
    SPrintf(result, "#caf - %d bones (%d with pos), %d bytes",
        caf.header.boneCount, posCount, caf.header.chunkSize);
    return result;
}

//------------------------------------------------
// DBA Animation Block (one animation in library)
// Similar structure to CAFChunk_Ivo but within a DBA container
//------------------------------------------------

struct DBAAnimationBlock_Ivo {
    AnimBlockHeader_Ivo header <bgcolor=cLtBlue, comment=PrintAnimBlockHeader_Ivo>;

    local int numBones = header.boneCount;
    local int64 blockStart = FTell() - 12;

    // Bone identification - CRC32 hashes matching skeleton bones
    uint32 boneHashes[numBones] <bgcolor=cLtPurple, comment="CRC32 bone identifiers">;

    // Controller entries - one per bone, 24 bytes each
    AnimControllerEntry_Ivo controllers[numBones] <bgcolor=cLtYellow, comment=PrintControllerEntry_Ivo>;

    // Mark the start of keyframe data section
    local int64 keyframeDataStart = FTell();
    local int64 blockEnd = blockStart + header.chunkSize;
    local int64 keyframeDataSize = blockEnd - keyframeDataStart;

    // For DBA blocks, just read the keyframe data as raw bytes for now
    // (can be expanded later with same logic as CAFChunk_Ivo)
    if (keyframeDataSize > 0) {
        ubyte keyframeData[keyframeDataSize] <bgcolor=cDkGray, comment="Keyframe data (rotation, time, position)">;
    }
};

string PrintDBABlock_Ivo(DBAAnimationBlock_Ivo &dba) {
    string result;
    local int posCount = 0;
    local int i;
    for (i = 0; i < dba.numBones; i++) {
        if (dba.controllers[i].posFormatFlags != 0) {
            posCount++;
        }
    }
    SPrintf(result, "#dba - %d bones (%d with pos), %d bytes",
        dba.header.boneCount, posCount, dba.header.dataSize);
    return result;
}

//------------------------------------------------
// DBA Data Chunk (contains multiple #dba blocks)
//------------------------------------------------

struct DBADataChunk_Ivo {
    uint32 totalDataSize <comment="Total size of all animation blocks">;

    local int64 dataEnd = FTell() + totalDataSize - 4;
    local int animIndex = 0;
    local char sig[4];

    while (FTell() < dataEnd) {
        ReadBytes(sig, FTell(), 4);
        if (sig[0] == '#' && sig[1] == 'd' && sig[2] == 'b' && sig[3] == 'a') {
            DBAAnimationBlock_Ivo animation <comment=PrintDBABlock_Ivo>;
            animIndex++;
        } else {
            break;
        }
    }
};

//------------------------------------------------
// DBA Metadata Entry (44 bytes each)
//------------------------------------------------

struct DBAMetaEntry_Ivo {
    uint16 numKeys;
    uint16 boneCount;
    uint32 flags;
    uint32 pathLength;
    Vector3 startPosition;
    Quaternion startRotation;
    uint32 padding;
};

string PrintDBAMetaEntry_Ivo(DBAMetaEntry_Ivo &entry) {
    string result;
    SPrintf(result, "Keys:%d Bones:%d PathLen:%d",
        entry.numKeys, entry.boneCount, entry.pathLength);
    return result;
}

//------------------------------------------------
// Animation Path String
//------------------------------------------------

struct AnimPathString_Ivo {
    string path;
};

string PrintAnimPath_Ivo(AnimPathString_Ivo &p) {
    return p.path;
}

//------------------------------------------------
// DBA Metadata Chunk
//------------------------------------------------

struct DBAMetadataChunk_Ivo {
    uint32 animCount <comment="Number of animations in library">;
    uint32 reserved;

    DBAMetaEntry_Ivo entries[animCount] <bgcolor=cLtRed, comment=PrintDBAMetaEntry_Ivo>;

    local int i;
    for (i = 0; i < animCount; i++) {
        AnimPathString_Ivo animPath <bgcolor=cWhite, comment=PrintAnimPath_Ivo>;
    }
};

#endif // CHUNKS_ANIMATION_BT

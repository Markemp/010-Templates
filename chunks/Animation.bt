//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: Animation.bt
//   Authors: Geoff Gerber
//   Purpose: Animation structures for all CryEngine formats
//            Includes CAF/DBA support for Star Citizen Ivo format
//------------------------------------------------

#ifndef CHUNKS_ANIMATION_BT
#define CHUNKS_ANIMATION_BT

#include "core/BaseTypes.bt"
#include "core/Enums.bt"
#include "core/Utilities.bt"
#include "display/PrintFunctions.bt"
#include "chunks/Header.bt"

//===========================================
// CryTek/CrChF Animation Structures
//===========================================

//------------------------------------------------
// Key Times Format Counts
// Stores count of tracks using each format type
//------------------------------------------------

struct KeyTimesFormatCounts {
    uint32 eF32;
    uint32 eUINT16;
    uint32 eByte;
    uint32 eF32StartStop;
    uint32 eUINT16StartStop;
    uint32 eByteStartStop;
    uint32 eBitset;
};

//------------------------------------------------
// Motion Parameters (v0905)
//------------------------------------------------

struct MotionParams905 {
    uint32 assetFlags;
    uint32 compression;
    int32 ticksPerFrame;
    float secsPerTick;
    int32 start;
    int32 end;
    float moveSpeed;
    float turnSpeed;
    float assetTurn;
    float distance;
    float slope;
    QuatT startLocation <comment=PrintQuatT>;
    QuatT endLocation <comment=PrintQuatT>;
    float lHeelStart;
    float lHeelEnd;
    float lToe0Start;
    float lToe0End;
    float rHeelStart;
    float rHeelEnd;
    float rToe0Start;
    float rToe0End;
};

//------------------------------------------------
// Controller Info (v0905)
//------------------------------------------------

struct CControllerInfo {
    uint32 controllerID;
    int32 posKeyTimeTrack;
    int32 posTrack;
    int32 rotKeyTimeTrack;
    int32 rotTrack;
};

//------------------------------------------------
// Animation Entry (v0905)
//------------------------------------------------

struct AnimationEntry(int isInPlaceStream) {
    uint16 filePathLength;
    if (filePathLength > 0) {
        char filePath[filePathLength];
    }
    MotionParams905 motionParams;
    uint16 footPlantBitsCount;
    if (footPlantBitsCount > 0) {
        ubyte footPlantBits[footPlantBitsCount];
    }
    uint16 controllerCount;
    if (isInPlaceStream) {
        // In-place streaming: controllers are in separate block, just store offset
        int32 offsetToControllerHeaders;
    } else {
        // Standard: controllers inline
        if (controllerCount > 0) {
            CControllerInfo controllers[controllerCount];
        }
    }
};

string PrintAnimationEntry(AnimationEntry &entry) {
    if (exists(entry.filePath)) {
        return entry.filePath;
    }
    return "<no path>";
}

//------------------------------------------------
// Controller Chunk Desc (v0905)
//------------------------------------------------

struct ControllerChunkDesc905 {
    uint32 numKeyPos;
    uint32 numKeyRot;
    uint32 numKeyTime;
    uint32 numAnims;
};

string PrintControllerChunkDesc905(ControllerChunkDesc905 &desc) {
    string result;
    SPrintf(result, "Pos:%d Rot:%d Time:%d Anims:%d",
        desc.numKeyPos, desc.numKeyRot, desc.numKeyTime, desc.numAnims);
    return result;
}

//------------------------------------------------
// Controller v0829 - CryTek/CrChF format
//------------------------------------------------

struct Controller829_Cry(FileFormat format) {
    ChunkHeader chunkHeader(format);

    uint controllerId;
    uint16 numRotationKeys;
    uint16 numPositionKeys;
    ECompressionFormat rotationFormat;
    EKeyTimesFormat rotationTimeFormat;
    ECompressionFormat positionFormat;
    ubyte positionKeyInfo;
    EKeyTimesFormat positionTimeFormat;
    ubyte tracksAligned;
    ushort padding;
   
    // Rotation Data
    if (numRotationKeys > 0) {
        switch (rotationFormat) {
            case eNoCompress:
            case eNoCompressQuat:
                NoCompressQuat rotationKeys[numRotationKeys];
                break;
            case eSmallTree48BitQuat:
                SmallTree48BitQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree48BitQuat>;
                break;
            case eSmallTree64BitQuat:
                SmallTree64BitQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree64BitQuat>;
                break;
            case eSmallTree64BitExtQuat:
                SmallTree64BitExtQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree64BitExtQuat>;
                break;
            default:
                ubyte rotationData[numRotationKeys * GetRotationSize(rotationFormat)];
                break;
        }

        if (tracksAligned != 0) {
            local int pos = FTell();
            local int padding = (4 - (pos % 4)) % 4;
            if (padding > 0) {
                ubyte rotationValuePadding[padding];
            }
        }

        switch (rotationTimeFormat) {
            case eF32:
            case eF32StartStop:
                F32KeyTime rotationTimes[numRotationKeys];
                break;
            case eUINT16:
            case eUINT16StartStop:
            case eBitset:
                Uint16KeyTime rotationTimes[numRotationKeys];
                break;
            case eByte:
            case eByteStartStop:
                ByteKeyTime rotationTimes[numRotationKeys] <comment=PrintByteKeyTime>;
                break;
            default:
                ubyte rotationTimeData[numRotationKeys * GetTimeKeySize(rotationTimeFormat)];
                break;
        }

        if (tracksAligned != 0) {
            local int pos = FTell();
            local int padding = (4 - (pos % 4)) % 4;
            if (padding > 0) {
                ubyte rotationTimePadding[padding];
            }
        }
    }

    // Position Data
    if (numPositionKeys > 0) {
        switch (positionFormat) {
            case eNoCompress:
            case eNoCompressVec3:
                Vector3 positionKeys[numPositionKeys] <comment=PrintVector3>;
                break;
            default:
                ubyte positionData[numPositionKeys * GetPositionSize(positionFormat)];
                break;
        }

        if (tracksAligned != 0) {
            local int pos = FTell();
            local int padding = (4 - (pos % 4)) % 4;
            if (padding > 0) {
                ubyte positionValuePadding[padding];
            }
        }

        if (positionKeyInfo != 0) {
            switch (positionTimeFormat) {
                case eF32:
                case eF32StartStop:
                    F32KeyTime positionTimes[numPositionKeys];
                    break;
                case eUINT16:
                case eUINT16StartStop:
                case eBitset:
                    Uint16KeyTime positionTimes[numPositionKeys];
                    break;
                case eByte:
                case eByteStartStop:
                    ByteKeyTime positionTimes[numPositionKeys] <comment=PrintByteKeyTime>;
                    break;
                default:
                    ubyte positionTimeData[numPositionKeys * GetTimeKeySize(positionTimeFormat)];
                    break;
            }

            if (tracksAligned != 0) {
                local int pos = FTell();
                local int padding = (4 - (pos % 4)) % 4;
                if (padding > 0) {
                    ubyte positionTimePadding[padding];
                }
            }
        }
    }
};

//------------------------------------------------
// Controller v0905 - CryTek/CrChF format
//------------------------------------------------

struct Controller905_Cry(FileFormat format) {
    ChunkHeader chunkHeader(format);

    ControllerChunkDesc905 header <comment=PrintControllerChunkDesc905>;

    // Size/format block
    // Note: Format is stored as count structures (counts per format type),
    // not as per-track format values
    uint16 keyTimeSizes[header.numKeyTime];
    KeyTimesFormatCounts keyTimeFormatCounts;
    uint16 positionSizes[header.numKeyPos];
    CompressionFormatCounts positionFormatCounts;
    uint16 rotationSizes[header.numKeyRot];
    CompressionFormatCounts rotationFormatCounts;

    // Offset arrays (+1 for end marker on rotation offsets)
    int32 keyTimeOffsets[header.numKeyTime];
    int32 positionOffsets[header.numKeyPos];
    int32 rotationOffsets[header.numKeyRot + 1];

    // Detect in-place streaming mode (negative offsets)
    local int isInPlaceStream = (header.numKeyTime > 0 && keyTimeOffsets[0] < 0);
    if (isInPlaceStream) {
        uint32 paddingLength;
        if (paddingLength > 0) {
            ubyte streamPadding[paddingLength];
        }
    }

    // Align to 4 bytes after size/offset block
    AlignTo4();

    // Track data size from terminator offset
    local int trackDataSize = 0;
    if (header.numKeyRot > 0) {
        trackDataSize = isInPlaceStream ? -rotationOffsets[header.numKeyRot] : rotationOffsets[header.numKeyRot];
    }

    // Non-in-place streaming: track data comes before animation entries
    if (!isInPlaceStream && trackDataSize > 0) {
        ubyte trackData[trackDataSize];
    }

    // Animation entries
    struct {
        local int i;
        for (i = 0; i < header.numAnims; i++) {
            AnimationEntry animation(isInPlaceStream) <comment=PrintAnimationEntry>;
        }
    } animations;

    // In-place streaming: controller headers and track data after animation entries
    if (isInPlaceStream) {
        // Calculate total controllers from all animation entries
        local int totalControllers = 0;
        local int j;
        for (j = 0; j < header.numAnims; j++) {
            totalControllers += animations.animation[j].controllerCount;
        }
        if (totalControllers > 0) {
            CControllerInfo controllerBlock[totalControllers];
        }

        // Track data is at the very end for in-place streaming
        AlignTo4();
        if (trackDataSize > 0) {
            ubyte trackData[trackDataSize];
        }
    }
};

//===========================================
// Ivo Animation Structures (CAF/DBA)
//===========================================

//------------------------------------------------
// Animation Info Chunk (CAF files, Version 0x0901)
// Contains metadata about the animation
//------------------------------------------------

struct AnimInfoChunk_Ivo {
    uint32 flags;                    // Animation flags (0=normal, 2=pose?)
    uint16 framesPerSecond;          // FPS - typically 30
    uint16 numBones;                 // Number of animated bones
    uint32 unknown2;                 // Reserved
    uint32 numPositionTracks;        // Number of bones with position animation
    float boundMin[3];               // Bounding box minimum (often 0,0,0)
    float scale;                     // Scale factor (typically ~1.0)
    double precision;                // Precision value for compression
    uint32 padding[2];               // Reserved padding
};

string PrintAnimInfo_Ivo(AnimInfoChunk_Ivo &info) {
    string result;
    SPrintf(result, "Flags:%d FPS:%d Bones:%d PosTracks:%d Scale:%.4f",
        info.flags, info.framesPerSecond, info.numBones, info.numPositionTracks, info.scale);
    return result;
}

//------------------------------------------------
// Controller Entry (shared by #caf and #dba)
// 24 bytes total - contains rotation and optional position track info
// Offsets are relative to the start of the keyframe data section
//------------------------------------------------

// Format flags for rotation/position tracks
// 0x8040 = rotation track present
// 0xC040 = position track present (bit 14 = 0x4000)
// Bit 6 (0x0040) and bit 15 (0x8000) appear always set for valid tracks

struct AnimControllerEntry_Ivo {
    // Rotation track info (12 bytes)
    ubyte numRotKeys;              // Number of rotation keyframes
    ubyte rotPadding;
    uint16 rotFormatFlags;         // 0x8040 = standard rotation track
    uint32 rotDataOffset;          // Offset to rotation quaternion data
    uint32 rotTimeOffset;          // Offset to rotation time keys

    // Position track info (12 bytes) - only valid if posFormatFlags != 0
    ubyte numPosKeys;              // Number of position keyframes (0 if none)
    ubyte posPadding;
    uint16 posFormatFlags;         // 0xC040 = has position, 0x0000 = none
    uint32 posDataOffset;          // Offset to position vector data
    uint32 posTimeOffset;          // Offset to position time keys
};

string PrintControllerEntry_Ivo(AnimControllerEntry_Ivo &ctrl) {
    string result;
    local int hasPos = (ctrl.posFormatFlags != 0);
    if (hasPos) {
        SPrintf(result, "Rot:%dkeys@0x%X Pos:%dkeys@0x%X",
            ctrl.numRotKeys, ctrl.rotDataOffset,
            ctrl.numPosKeys, ctrl.posDataOffset);
    } else {
        SPrintf(result, "Rot:%dkeys@0x%X (no pos)",
            ctrl.numRotKeys, ctrl.rotDataOffset);
    }
    return result;
}

//------------------------------------------------
// Animation Block Header (12 bytes)
//------------------------------------------------

struct AnimBlockHeader_Ivo {
    char signature[4];
    ubyte boneCount;
    ubyte padding;
    uint16 magic;
    uint32 dataSize;
};

string PrintAnimBlockHeader_Ivo(AnimBlockHeader_Ivo &hdr) {
    string result;
    SPrintf(result, "%c%c%c%c Bones: %d, Magic: 0x%04X, Size: %d",
        hdr.signature[0], hdr.signature[1], hdr.signature[2], hdr.signature[3],
        hdr.boneCount, hdr.magic, hdr.dataSize);
    return result;
}

//------------------------------------------------
// Keyframe Data Structures for Ivo CAF
//------------------------------------------------

// Uncompressed quaternion (16 bytes) - used in Ivo CAF
struct UncompressedQuat_Ivo {
    float x;
    float y;
    float z;
    float w;
};

string PrintUncompressedQuat_Ivo(UncompressedQuat_Ivo &q) {
    string result;
    SPrintf(result, "(%.4f, %.4f, %.4f, %.4f)", q.x, q.y, q.z, q.w);
    return result;
}

//------------------------------------------------
// CAF Chunk (single animation)
// Contains bone hashes, controller entries, and keyframe data
//------------------------------------------------

struct CAFChunk_Ivo {
    AnimBlockHeader_Ivo header <bgcolor=cLtBlue, comment=PrintAnimBlockHeader_Ivo>;

    local int numBones = header.boneCount;
    local int64 blockStart = FTell() - 12;

    // Bone identification - CRC32 hashes matching skeleton bones
    uint32 boneHashes[numBones] <bgcolor=cLtGreen, comment="CRC32 bone identifiers">;

    // Controller entries - one per bone, 24 bytes each
    AnimControllerEntry_Ivo controllers[numBones] <bgcolor=cLtYellow, comment=PrintControllerEntry_Ivo>;

    // Mark the start of keyframe data section
    // All controller offsets are relative to this position
    local int64 keyframeDataStart = FTell();

    // Calculate block end based on header dataSize
    // Note: dataSize appears to INCLUDE the 12-byte header
    local int64 blockEnd = blockStart + header.dataSize;
    local int64 keyframeDataSize = blockEnd - keyframeDataStart;

    // Count total keys for display
    local int i;
    local int totalRotKeys = 0;
    local int totalPosKeys = 0;
    for (i = 0; i < numBones; i++) {
        totalRotKeys += controllers[i].numRotKeys;
        if (controllers[i].posFormatFlags != 0) {
            totalPosKeys += controllers[i].numPosKeys;
        }
    }

    // Parse the keyframe data section
    // Layout observed:
    //   0x37C: 4-byte header (0x00000100)
    //   0x380: Rotation quaternions start (uncompressed 16-byte quats)
    //   Then: Time data
    //   Then: Position data (for bones with position tracks)
    //
    // Controller offsets are relative to keyframeDataStart (0x37C)
    // but the actual quaternion data starts at offset 0x4 (after the header)

    if (keyframeDataSize > 0) {
        // Read the 4-byte keyframe section header
        if (keyframeDataSize >= 4) {
            uint32 keyframeHeader <bgcolor=cDkGray, comment="Keyframe section header">;
        }

        // Read rotation quaternions
        // Total quaternions = sum of all numRotKeys
        if (totalRotKeys > 0 && (keyframeDataSize - 4) >= (totalRotKeys * 16)) {
            UncompressedQuat_Ivo rotationQuats[totalRotKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
        }

        // Read remaining data (time keys, position data)
        local int64 remainingSize = blockEnd - FTell();
        if (remainingSize > 0) {
            ubyte timeAndPositionData[remainingSize] <bgcolor=cSilver, comment="Time keys and position data">;
        }
    }
};

string PrintCAFChunk_Ivo(CAFChunk_Ivo &caf) {
    string result;
    local int posCount = 0;
    local int i;
    for (i = 0; i < caf.numBones; i++) {
        if (caf.controllers[i].posFormatFlags != 0) {
            posCount++;
        }
    }
    SPrintf(result, "#caf - %d bones (%d with pos), %d bytes",
        caf.header.boneCount, posCount, caf.header.dataSize);
    return result;
}

//------------------------------------------------
// DBA Animation Block (one animation in library)
// Similar structure to CAFChunk_Ivo but within a DBA container
//------------------------------------------------

struct DBAAnimationBlock_Ivo {
    AnimBlockHeader_Ivo header <bgcolor=cLtBlue, comment=PrintAnimBlockHeader_Ivo>;

    local int numBones = header.boneCount;
    local int64 blockStart = FTell() - 12;

    // Bone identification - CRC32 hashes matching skeleton bones
    uint32 boneHashes[numBones] <bgcolor=cLtPurple, comment="CRC32 bone identifiers">;

    // Controller entries - one per bone, 24 bytes each
    AnimControllerEntry_Ivo controllers[numBones] <bgcolor=cLtYellow, comment=PrintControllerEntry_Ivo>;

    // Mark the start of keyframe data section
    // Note: dataSize appears to INCLUDE the 12-byte header
    local int64 keyframeDataStart = FTell();
    local int64 blockEnd = blockStart + header.dataSize;
    local int64 keyframeDataSize = blockEnd - keyframeDataStart;

    // For DBA blocks, just read the keyframe data as raw bytes for now
    // (can be expanded later with same logic as CAFChunk_Ivo)
    if (keyframeDataSize > 0) {
        ubyte keyframeData[keyframeDataSize] <bgcolor=cDkGray, comment="Keyframe data (rotation, time, position)">;
    }
};

string PrintDBABlock_Ivo(DBAAnimationBlock_Ivo &dba) {
    string result;
    local int posCount = 0;
    local int i;
    for (i = 0; i < dba.numBones; i++) {
        if (dba.controllers[i].posFormatFlags != 0) {
            posCount++;
        }
    }
    SPrintf(result, "#dba - %d bones (%d with pos), %d bytes",
        dba.header.boneCount, posCount, dba.header.dataSize);
    return result;
}

//------------------------------------------------
// DBA Data Chunk (contains multiple #dba blocks)
//------------------------------------------------

struct DBADataChunk_Ivo {
    uint32 totalDataSize <comment="Total size of all animation blocks">;

    local int64 dataEnd = FTell() + totalDataSize - 4;
    local int animIndex = 0;
    local char sig[4];

    while (FTell() < dataEnd) {
        ReadBytes(sig, FTell(), 4);
        if (sig[0] == '#' && sig[1] == 'd' && sig[2] == 'b' && sig[3] == 'a') {
            DBAAnimationBlock_Ivo animation <comment=PrintDBABlock_Ivo>;
            animIndex++;
        } else {
            break;
        }
    }
};

//------------------------------------------------
// DBA Metadata Entry (44 bytes each)
//------------------------------------------------

struct DBAMetaEntry_Ivo {
    uint16 numKeys;
    uint16 boneCount;
    uint32 flags;
    uint32 pathLength;
    Vector3 startPosition;
    Quaternion startRotation;
    uint32 padding;
};

string PrintDBAMetaEntry_Ivo(DBAMetaEntry_Ivo &entry) {
    string result;
    SPrintf(result, "Keys:%d Bones:%d PathLen:%d",
        entry.numKeys, entry.boneCount, entry.pathLength);
    return result;
}

//------------------------------------------------
// Animation Path String
//------------------------------------------------

struct AnimPathString_Ivo {
    string path;
};

string PrintAnimPath_Ivo(AnimPathString_Ivo &p) {
    return p.path;
}

//------------------------------------------------
// DBA Metadata Chunk
//------------------------------------------------

struct DBAMetadataChunk_Ivo {
    uint32 animCount <comment="Number of animations in library">;
    uint32 reserved;

    DBAMetaEntry_Ivo entries[animCount] <bgcolor=cLtRed, comment=PrintDBAMetaEntry_Ivo>;

    local int i;
    for (i = 0; i < animCount; i++) {
        AnimPathString_Ivo animPath <bgcolor=cWhite, comment=PrintAnimPath_Ivo>;
    }
};

#endif // CHUNKS_ANIMATION_BT

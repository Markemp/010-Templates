//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: Animation.bt
//   Authors: Geoff Gerber
//   Purpose: Animation structures for all CryEngine formats
//            Includes CAF/DBA support for Star Citizen Ivo format
//------------------------------------------------

#ifndef CHUNKS_ANIMATION_BT
#define CHUNKS_ANIMATION_BT

#include "core/BaseTypes.bt"
#include "core/Enums.bt"
#include "core/Utilities.bt"
#include "display/PrintFunctions.bt"
#include "chunks/Header.bt"

//===========================================
// CryTek/CrChF Animation Structures
//===========================================

//------------------------------------------------
// Key Times Format Counts
// Stores count of tracks using each format type
//------------------------------------------------

struct KeyTimesFormatCounts {
    uint32 eF32;
    uint32 eUINT16;
    uint32 eByte;
    uint32 eF32StartStop;
    uint32 eUINT16StartStop;
    uint32 eByteStartStop;
    uint32 eBitset;
};

//------------------------------------------------
// Motion Parameters (v0905)
//------------------------------------------------

struct MotionParams905 {
    uint32 assetFlags;
    uint32 compression;
    int32 ticksPerFrame;
    float secsPerTick;
    int32 start;
    int32 end;
    float moveSpeed;
    float turnSpeed;
    float assetTurn;
    float distance;
    float slope;
    QuatT startLocation <comment=PrintQuatT>;
    QuatT endLocation <comment=PrintQuatT>;
    float lHeelStart;
    float lHeelEnd;
    float lToe0Start;
    float lToe0End;
    float rHeelStart;
    float rHeelEnd;
    float rToe0Start;
    float rToe0End;
};

//------------------------------------------------
// Controller Info (v0905)
//------------------------------------------------

struct CControllerInfo {
    uint32 controllerID;
    int32 posKeyTimeTrack;
    int32 posTrack;
    int32 rotKeyTimeTrack;
    int32 rotTrack;
};

//------------------------------------------------
// Animation Entry (v0905)
//------------------------------------------------

struct AnimationEntry(int isInPlaceStream) {
    uint16 filePathLength;
    if (filePathLength > 0) {
        char filePath[filePathLength];
    }
    MotionParams905 motionParams;
    uint16 footPlantBitsCount;
    if (footPlantBitsCount > 0) {
        ubyte footPlantBits[footPlantBitsCount];
    }
    uint16 controllerCount;
    if (isInPlaceStream) {
        // In-place streaming: controllers are in separate block, just store offset
        int32 offsetToControllerHeaders;
    } else {
        // Standard: controllers inline
        if (controllerCount > 0) {
            CControllerInfo controllers[controllerCount];
        }
    }
};

string PrintAnimationEntry(AnimationEntry &entry) {
    if (exists(entry.filePath)) {
        return entry.filePath;
    }
    return "<no path>";
}

//------------------------------------------------
// Controller Chunk Desc (v0905)
//------------------------------------------------

struct ControllerChunkDesc905 {
    uint32 numKeyPos;
    uint32 numKeyRot;
    uint32 numKeyTime;
    uint32 numAnims;
};

string PrintControllerChunkDesc905(ControllerChunkDesc905 &desc) {
    string result;
    SPrintf(result, "Pos:%d Rot:%d Time:%d Anims:%d",
        desc.numKeyPos, desc.numKeyRot, desc.numKeyTime, desc.numAnims);
    return result;
}

//------------------------------------------------
// Controller v0829 - CryTek/CrChF format
//------------------------------------------------

struct Controller829_Cry(FileFormat format) {
    ChunkHeader chunkHeader(format);

    uint controllerId;
    uint16 numRotationKeys;
    uint16 numPositionKeys;
    ECompressionFormat rotationFormat;
    EKeyTimesFormat rotationTimeFormat;
    ECompressionFormat positionFormat;
    ubyte positionKeyInfo;
    EKeyTimesFormat positionTimeFormat;
    ubyte tracksAligned;
    ushort reserved;

    // Local variables for alignment calculations (declared once)
    local int alignPos;
    local int alignPad;
    local int64 fileSize = FileSize();

    // Rotation Data
    if (numRotationKeys > 0) {
        switch (rotationFormat) {
            case eNoCompress:
            case eNoCompressQuat:
                NoCompressQuat rotationKeys[numRotationKeys];
                break;
            case eSmallTree48BitQuat:
                SmallTree48BitQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree48BitQuat>;
                break;
            case eSmallTree64BitQuat:
                SmallTree64BitQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree64BitQuat>;
                break;
            case eSmallTree64BitExtQuat:
                SmallTree64BitExtQuat rotationKeys[numRotationKeys] <comment=PrintSmallTree64BitExtQuat>;
                break;
            default:
                ubyte rotationData[numRotationKeys * GetRotationSize(rotationFormat)];
                break;
        }

        if (tracksAligned != 0) {
            alignPos = FTell();
            alignPad = (4 - (alignPos % 4)) % 4;
            if (alignPad > 0 && alignPos + alignPad <= fileSize) {
                ubyte rotationValuePadding[alignPad];
            }
        }

        switch (rotationTimeFormat) {
            case eF32:
            case eF32StartStop:
                F32KeyTime rotationTimes[numRotationKeys];
                break;
            case eUINT16:
            case eUINT16StartStop:
            case eBitset:
                Uint16KeyTime rotationTimes[numRotationKeys] <comment=PrintUint16KeyTime>;
                break;
            case eByte:
            case eByteStartStop:
                ByteKeyTime rotationTimes[numRotationKeys] <comment=PrintByteKeyTime>;
                break;
            default:
                ubyte rotationTimeData[numRotationKeys * GetTimeKeySize(rotationTimeFormat)];
                break;
        }

        if (tracksAligned != 0) {
            alignPos = FTell();
            alignPad = (4 - (alignPos % 4)) % 4;
            if (alignPad > 0 && alignPos + alignPad <= fileSize) {
                ubyte rotationTimePadding[alignPad];
            }
        }
    }

    // Position Data
    if (numPositionKeys > 0) {
        switch (positionFormat) {
            case eNoCompress:
            case eNoCompressVec3:
                Vector3 positionKeys[numPositionKeys] <comment=PrintVector3>;
                break;
            default:
                ubyte positionData[numPositionKeys * GetPositionSize(positionFormat)];
                break;
        }

        if (tracksAligned != 0) {
            alignPos = FTell();
            alignPad = (4 - (alignPos % 4)) % 4;
            if (alignPad > 0 && alignPos + alignPad <= fileSize) {
                ubyte positionValuePadding[alignPad];
            }
        }

        if (positionKeyInfo != 0) {
            switch (positionTimeFormat) {
                case eF32:
                case eF32StartStop:
                    F32KeyTime positionTimes[numPositionKeys];
                    break;
                case eUINT16:
                case eUINT16StartStop:
                case eBitset:
                    Uint16KeyTime positionTimes[numPositionKeys] <comment=PrintUint16KeyTime>;
                    break;
                case eByte:
                case eByteStartStop:
                    ByteKeyTime positionTimes[numPositionKeys] <comment=PrintByteKeyTime>;
                    break;
                default:
                    ubyte positionTimeData[numPositionKeys * GetTimeKeySize(positionTimeFormat)];
                    break;
            }

            if (tracksAligned != 0) {
                alignPos = FTell();
                alignPad = (4 - (alignPos % 4)) % 4;
                if (alignPad > 0 && alignPos + alignPad <= fileSize) {
                    ubyte positionTimePadding[alignPad];
                }
            }
        }
    }
};

//------------------------------------------------
// Controller v0905 - CryTek/CrChF format
//------------------------------------------------

struct Controller905_Cry(FileFormat format) {
    ChunkHeader chunkHeader(format);

    ControllerChunkDesc905 header <comment=PrintControllerChunkDesc905>;

    // Size/format block
    // Note: Format is stored as count structures (counts per format type),
    // not as per-track format values
    uint16 keyTimeSizes[header.numKeyTime];
    KeyTimesFormatCounts keyTimeFormatCounts;
    uint16 positionSizes[header.numKeyPos];
    CompressionFormatCounts positionFormatCounts;
    uint16 rotationSizes[header.numKeyRot];
    CompressionFormatCounts rotationFormatCounts;

    // Offset arrays (+1 for end marker on rotation offsets)
    int32 keyTimeOffsets[header.numKeyTime];
    int32 positionOffsets[header.numKeyPos];
    int32 rotationOffsets[header.numKeyRot + 1];

    // Detect in-place streaming mode (negative offsets)
    local int isInPlaceStream = (header.numKeyTime > 0 && keyTimeOffsets[0] < 0);
    if (isInPlaceStream) {
        uint32 paddingLength;
        if (paddingLength > 0) {
            ubyte streamPadding[paddingLength];
        }
    }

    // Align to 4 bytes after size/offset block
    AlignTo4();

    // Track data size from terminator offset
    local int trackDataSize = 0;
    if (header.numKeyRot > 0) {
        trackDataSize = isInPlaceStream ? -rotationOffsets[header.numKeyRot] : rotationOffsets[header.numKeyRot];
    }

    // Non-in-place streaming: track data comes before animation entries
    if (!isInPlaceStream && trackDataSize > 0) {
        ubyte trackData[trackDataSize];
    }

    // Animation entries
    struct {
        local int i;
        for (i = 0; i < header.numAnims; i++) {
            AnimationEntry animation(isInPlaceStream) <comment=PrintAnimationEntry>;
        }
    } animations;

    // In-place streaming: controller headers and track data after animation entries
    if (isInPlaceStream) {
        // Calculate total controllers from all animation entries
        local int totalControllers = 0;
        local int j;
        for (j = 0; j < header.numAnims; j++) {
            totalControllers += animations.animation[j].controllerCount;
        }
        if (totalControllers > 0) {
            CControllerInfo controllerBlock[totalControllers];
        }

        // Track data is at the very end for in-place streaming
        AlignTo4();
        if (trackDataSize > 0) {
            ubyte trackData[trackDataSize];
        }
    }
};

//===========================================
// Ivo Animation Structures (CAF/DBA)
//===========================================

//------------------------------------------------
// Animation Info Chunk (CAF files, Version 0x0901)
// Contains metadata about the animation
//------------------------------------------------

struct AnimInfoChunk_Ivo {
    uint32 flags;                    // Animation flags (0=normal, 2=pose?)
    uint16 framesPerSecond;          // FPS - typically 30
    uint16 numBones;                 // Number of animated bones
    uint32 unknown2;                 // Reserved
    uint32 endFrame;                 // Last frame number (matches timeEnd in time keys)
    Quaternion startRotation <comment=PrintQuaternion>;
    Vector3 startPosition <comment=PrintVector3>;
    uint32 padding;                  // Reserved padding
};

string PrintAnimInfo_Ivo(AnimInfoChunk_Ivo &info) {
    string result;
    SPrintf(result, "Flags:%d FPS:%d Bones:%d EndFrame:%d",
        info.flags, info.framesPerSecond, info.numBones, info.endFrame);
    return result;
}

//------------------------------------------------
// Controller Entry (shared by #caf and #dba)
// 24 bytes total - contains rotation and optional position track info
// Offsets are relative to the start of the keyframe data section
//------------------------------------------------

// Format flags for rotation/position tracks
// 0x8040 = rotation track present
// 0xC040 = position track present (bit 14 = 0x4000)
// Bit 6 (0x0040) and bit 15 (0x8000) appear always set for valid tracks

// Time header structure (8 bytes) - appears before time/data blocks
struct AnimTimeHeader_Ivo {
    uint16 startTime;              // Start time (usually 0)
    uint16 endTime;                // End time (e.g., 0x1E = 30)
    uint32 marker;                 // Marker value (0x7FFFFFFF, 0x5FFFFFFF, etc.)
};

string PrintAnimTimeHeader_Ivo(AnimTimeHeader_Ivo &h) {
    string result;
    SPrintf(result, "time: %d-%d, marker=0x%08X", h.startTime, h.endTime, h.marker);
    return result;
}

// Controller entry structure (24 bytes) - used by DBA blocks
struct AnimControllerEntry_Ivo {
    uint16 numRotKeys;
    uint16 rotFormatFlags;
    uint32 rotTimeOffset;
    uint32 rotDataOffset;
    uint16 numPosKeys;
    uint16 posFormatFlags;
    uint32 posTimeOffset;
    uint32 posDataOffset;
};

string PrintControllerEntry_Ivo(AnimControllerEntry_Ivo &ctrl) {
    string result;
    local int hasPos = (ctrl.posFormatFlags != 0);
    local int rotGap = ctrl.rotDataOffset - ctrl.rotTimeOffset;
    if (hasPos) {
        local int posGap = ctrl.posDataOffset - ctrl.posTimeOffset;
        SPrintf(result, "Rot:%dkeys @time=0x%X @data=0x%X (gap=%d) flags=0x%04X | Pos:%dkeys @time=0x%X @data=0x%X (gap=%d) flags=0x%04X",
            ctrl.numRotKeys, ctrl.rotTimeOffset, ctrl.rotDataOffset, rotGap, ctrl.rotFormatFlags,
            ctrl.numPosKeys, ctrl.posTimeOffset, ctrl.posDataOffset, posGap, ctrl.posFormatFlags);
    } else {
        SPrintf(result, "Rot:%dkeys @time=0x%X @data=0x%X (gap=%d) flags=0x%04X",
            ctrl.numRotKeys, ctrl.rotTimeOffset, ctrl.rotDataOffset, rotGap, ctrl.rotFormatFlags);
    }
    return result;
}

//------------------------------------------------
// Animation Block Header (12 bytes)
//------------------------------------------------

struct AnimBlockHeader_Ivo {
    char signature[4];
    uint16 boneCount;              // Number of bones (up to 1024 in CryEngine)
    uint16 magic;
    uint32 chunkSize;
};

string PrintAnimBlockHeader_Ivo(AnimBlockHeader_Ivo &hdr) {
    string result;
    SPrintf(result, "%c%c%c%c Bones: %d, Magic: 0x%04X, Size: %d",
        hdr.signature[0], hdr.signature[1], hdr.signature[2], hdr.signature[3],
        hdr.boneCount, hdr.magic, hdr.chunkSize);
    return result;
}

//------------------------------------------------
// Keyframe Data Structures for Ivo CAF
//------------------------------------------------

// Per-bone data header (8 bytes) - appears before each bone's rotation data
struct BoneDataHeader_Ivo {
    uint16 padding;           // Usually 0
    uint16 value;             // Often 0x1E (30) - possibly key count or frame count
    uint32 marker;            // 0x7FFFFFFF or 0x5FFFFFFF - sentinel/marker
};

string PrintBoneDataHeader_Ivo(BoneDataHeader_Ivo &h) {
    string result;
    SPrintf(result, "value=%d marker=0x%08X", h.value, h.marker);
    return result;
}

// Uncompressed quaternion (16 bytes) - used in Ivo CAF
struct UncompressedQuat_Ivo {
    float x;
    float y;
    float z;
    float w;
};

string PrintUncompressedQuat_Ivo(UncompressedQuat_Ivo &q) {
    string result;
    local float mag = Sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
    local string normStr = (mag > 0.98 && mag < 1.02) ? " [OK]" : " [BAD]";
    SPrintf(result, "(%.4f, %.4f, %.4f, %.4f) mag=%.4f%s", q.x, q.y, q.z, q.w, mag, normStr);
    return result;
}

// SNORM Vector3 (6 bytes) - int16 values normalized to -1.0 to 1.0
struct SNORMVector3_Ivo {
    int16 x;
    int16 y;
    int16 z;
};

string PrintSNORMVector3_Ivo(SNORMVector3_Ivo &v) {
    string result;
    SPrintf(result, "(%d, %d, %d)", v.x, v.y, v.z);
    return result;
}

// Scaled SNORM Vector3 - stores scale for comment display
struct ScaledSNORMPos_Ivo(float scaleX, float scaleY, float scaleZ) {
    local float sx = scaleX;
    local float sy = scaleY;
    local float sz = scaleZ;
    int16 x;
    int16 y;
    int16 z;
};

string PrintScaledSNORMPos_Ivo(ScaledSNORMPos_Ivo &p) {
    string result;
    // Convert SNORM to float: value / 32767.0 * scale
    local float fx = (p.x / 32767.0) * p.sx;
    local float fy = (p.y / 32767.0) * p.sy;
    local float fz = (p.z / 32767.0) * p.sz;
    SPrintf(result, "(%.6f, %.6f, %.6f)", fx, fy, fz);
    return result;
}

//------------------------------------------------
// Position Header for 0xC2xx formats (24 bytes)
// Contains channel mask and scale factors
//------------------------------------------------

// FLT_MAX threshold for detecting inactive channels
// 0x7F7FFFFF = 3.4028234e+38
local float FLT_MAX_THRESHOLD = 3.4e38;

struct PosHeader_C2_Ivo {
    Vector3 channelMask <comment="FLT_MAX = channel not animated">;
    Vector3 scale <comment=PrintVector3>;
};

string PrintPosHeader_C2_Ivo(PosHeader_C2_Ivo &h) {
    string result;
    local string xStatus = (h.channelMask.x > 3.4e38) ? "OFF" : "ON";
    local string yStatus = (h.channelMask.y > 3.4e38) ? "OFF" : "ON";
    local string zStatus = (h.channelMask.z > 3.4e38) ? "OFF" : "ON";
    SPrintf(result, "X=%s Y=%s Z=%s | Scale: (%.6f, %.6f, %.6f)",
        xStatus, yStatus, zStatus, h.scale.x, h.scale.y, h.scale.z);
    return result;
}

//------------------------------------------------
// Packed SNORM Position - only stores active channels
// Inactive channels are assumed to be 0
// Includes scale for proper value display
//------------------------------------------------

struct PackedSNORMPos_Ivo(int xActive, int yActive, int zActive, float scaleX, float scaleY, float scaleZ) {
    local int ax = xActive;
    local int ay = yActive;
    local int az = zActive;
    local float sx = scaleX;
    local float sy = scaleY;
    local float sz = scaleZ;
    if (xActive) int16 x;
    if (yActive) int16 y;
    if (zActive) int16 z;
};

string PrintPackedSNORMPos_Ivo(PackedSNORMPos_Ivo &p) {
    string result;
    // Convert SNORM to float: value / 32767.0 * scale
    // Inactive channels show 0.0
    local float fx = p.ax ? ((exists(p.x) ? p.x : 0) / 32767.0) * p.sx : 0.0;
    local float fy = p.ay ? ((exists(p.y) ? p.y : 0) / 32767.0) * p.sy : 0.0;
    local float fz = p.az ? ((exists(p.z) ? p.z : 0) / 32767.0) * p.sz : 0.0;
    SPrintf(result, "(%.6f, %.6f, %.6f)", fx, fy, fz);
    return result;
}

// Bone rotation track - header + quaternions
struct BoneRotationTrack_Ivo(int numKeys) {
    BoneDataHeader_Ivo header <bgcolor=cDkGray, comment=PrintBoneDataHeader_Ivo>;
    if (numKeys > 0) {
        UncompressedQuat_Ivo rotations[numKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
    }
};

//------------------------------------------------
// CAF Chunk (single animation)
// Contains bone hashes, controller entries, and keyframe data
// Animation data is read using offsets from the start of the controllers array
//------------------------------------------------

struct CAFChunk_Ivo {
    AnimBlockHeader_Ivo header <bgcolor=cLtBlue, comment=PrintAnimBlockHeader_Ivo>;

    local int numBones = header.boneCount;
    local int64 blockStart = FTell() - 12;
    local int64 blockEnd = blockStart + header.chunkSize;

    // Bone identification - CRC32 hashes matching skeleton bones
    uint32 boneHashes[numBones] <bgcolor=cLtGreen, comment="CRC32 bone identifiers">;

    // Mark the start of controllers - all offsets are relative to this position
    local int64 controllersStart = FTell();

    // Read each controller with its associated animation data
    local int b;
    for (b = 0; b < numBones; b++) {
        struct AnimController_Ivo {
            // Track start of this controller - offsets are relative to here
            local int64 controllerStart = FTell();

            // Controller header (24 bytes)
            uint16 numRotKeys;
            uint16 rotFormatFlags;
            uint32 rotTimeOffset;
            uint32 rotDataOffset;
            uint16 numPosKeys;
            uint16 posFormatFlags;
            uint32 posTimeOffset;
            uint32 posDataOffset;

            // Save position after reading controller header
            local int64 savedPos = FTell();

            // Read rotation time and data if present
            // Format flags: 0x8040 = ubyte time array, 0x8042 = uint16 time with 8-byte header
            if (numRotKeys > 0 && rotTimeOffset > 0) {
                FSeek(controllerStart + rotTimeOffset);
                local ubyte rotFormat = rotFormatFlags & 0x0F;  // Low nibble: 0=ubyte time, 2=uint16 time

                if (rotFormat == 0x00) {
                    // 0x8040: ubyte time array (padded to 4-byte boundary)
                    ubyte rotTimeData[numRotKeys] <bgcolor=cDkGray, comment="Rotation time keys (ubyte)">;
                } else {
                    // 0x8042: 8-byte time header (startTime, endTime, marker)
                    AnimTimeHeader_Ivo rotTimeHeader <bgcolor=cDkGray, comment=PrintAnimTimeHeader_Ivo>;
                }

                FSeek(controllerStart + rotDataOffset);
                UncompressedQuat_Ivo rotations[numRotKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
            }

            // Read position time and data if present
            if (numPosKeys > 0 && posFormatFlags != 0) {
                // Position format flags:
                //   0xC0xx: float-based Vector3 (12 bytes per key)
                //   0xC2xx: SNORM int16-based Vector3 (6 bytes per key)
                // Low nibble: 0x40=ubyte time, 0x42=uint16 time with header
                local ubyte posFormat = posFormatFlags & 0x0F;

                // Read position time data
                FSeek(controllerStart + posTimeOffset);

                // 0x40 (low nibble 0) = ubyte time, 0x42 (low nibble 2) = uint16 time
                if (posFormat == 0x00) {
                    // ubyte time format (4 bytes for numPosKeys times)
                    ubyte posTimeData[numPosKeys] <bgcolor=cDkGray, comment="Position time keys (ubyte)">;
                } else {
                    // uint16 time format with marker (8 bytes total)
                    struct PosTimeBlock {
                        uint16 timeStart;
                        uint16 timeEnd;
                        uint32 marker;
                    } posTimeData <bgcolor=cDkGray, comment=Str("time: %d-%d, marker=0x%08X", this.timeStart, this.timeEnd, this.marker)>;
                }

                // Read position data (separate location)
                FSeek(controllerStart + posDataOffset);

                // Position format based on high byte:
                // 0xC0xx: float-based Vector3 (12 bytes per key), no header
                // 0xC1xx: 24-byte header + full SNORMVector3 (all channels, 6 bytes per key)
                // 0xC2xx: 24-byte header + packed SNORMs for active channels only
                local ubyte posHighByte = (posFormatFlags >> 8) & 0xFF;
                if (posHighByte == 0xC0) {
                    // Float Vector3 - no header
                    Vector3 positions[numPosKeys] <bgcolor=cLtGreen, comment=PrintVector3>;
                } else if (posHighByte == 0xC1) {
                    // SNORM with header - all channels present
                    PosHeader_C2_Ivo posHeader <bgcolor=cDkGreen, comment=PrintPosHeader_C2_Ivo>;
                    struct {
                        local int pk;
                        for (pk = 0; pk < numPosKeys; pk++) {
                            ScaledSNORMPos_Ivo position(posHeader.scale.x, posHeader.scale.y, posHeader.scale.z) <bgcolor=cLtGreen, comment=PrintScaledSNORMPos_Ivo>;
                        }
                    } positions <comment="Scaled SNORM positions">;
                } else if (posHighByte == 0xC2) {
                    // SNORM with header - read header first
                    PosHeader_C2_Ivo posHeader <bgcolor=cDkGreen, comment=PrintPosHeader_C2_Ivo>;

                    // Determine active channels
                    local int xActive = (posHeader.channelMask.x < 3.4e38) ? 1 : 0;
                    local int yActive = (posHeader.channelMask.y < 3.4e38) ? 1 : 0;
                    local int zActive = (posHeader.channelMask.z < 3.4e38) ? 1 : 0;
                    // Read packed SNORM positions (only active channels stored)
                    struct {
                        local int pk;
                        for (pk = 0; pk < numPosKeys; pk++) {
                            PackedSNORMPos_Ivo position(xActive, yActive, zActive, posHeader.scale.x, posHeader.scale.y, posHeader.scale.z) <bgcolor=cLtGreen, comment=PrintPackedSNORMPos_Ivo>;
                        }
                    } positions <comment="Packed SNORM positions">;
                } else {
                    // Unknown format - read as raw bytes (estimate 12 bytes per key)
                    ubyte posDataRaw[numPosKeys * 12] <bgcolor=cRed, comment="Unknown position format">;
                }
            }

            // Restore position for next controller
            FSeek(savedPos);
        } controller <bgcolor=cLtYellow,
                      comment=Str("Rot=%d keys (flags=0x%04X), Pos=%d keys (flags=0x%04X)", this.numRotKeys, this.rotFormatFlags, this.numPosKeys, this.posFormatFlags)>;
    }

    // Seek to end of block
    FSeek(blockEnd);
};

string PrintCAFChunk_Ivo(CAFChunk_Ivo &caf) {
    string result;
    local int posCount = 0;
    local int i;
    for (i = 0; i < caf.numBones; i++) {
        if (caf.controller[i].posFormatFlags != 0) {
            posCount++;
        }
    }
    SPrintf(result, "#caf - %d bones (%d with pos), %d bytes",
        caf.header.boneCount, posCount, caf.header.chunkSize);
    return result;
}

//------------------------------------------------
// DBA Animation Block (one animation in library)
// Similar structure to CAFChunk_Ivo but within a DBA container
//------------------------------------------------

struct DBAAnimationBlock_Ivo {
    AnimBlockHeader_Ivo header <bgcolor=cLtBlue, comment=PrintAnimBlockHeader_Ivo>;

    local int numBones = header.boneCount;
    local int64 blockStart = FTell() - 12;
    local int64 blockEnd = blockStart + header.chunkSize;

    // Bone identification - CRC32 hashes matching skeleton bones
    uint32 boneHashes[numBones] <bgcolor=cLtPurple, comment="CRC32 bone identifiers">;

    // Controller entries with keyframe data (same as CAF format)
    local int c;
    for (c = 0; c < numBones; c++) {
        struct DBAAnimController_Ivo {
            local int64 controllerStart = FTell();

            // Controller header (24 bytes)
            uint16 numRotKeys;
            uint16 rotFormatFlags;
            uint32 rotTimeOffset;
            uint32 rotDataOffset;
            uint16 numPosKeys;
            uint16 posFormatFlags;
            uint32 posTimeOffset;
            uint32 posDataOffset;

            local int64 savedPos = FTell();

            // Read rotation time and data if present
            if (numRotKeys > 0 && rotTimeOffset > 0) {
                FSeek(controllerStart + rotTimeOffset);
                local ubyte rotFormat = rotFormatFlags & 0x0F;

                if (rotFormat == 0x00) {
                    ubyte rotTimeData[numRotKeys] <bgcolor=cDkGray, comment="Rotation time keys (ubyte)">;
                } else {
                    AnimTimeHeader_Ivo rotTimeHeader <bgcolor=cDkGray, comment=PrintAnimTimeHeader_Ivo>;
                }

                FSeek(controllerStart + rotDataOffset);
                UncompressedQuat_Ivo rotations[numRotKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
            }

            // Read position time and data if present
            if (numPosKeys > 0 && posFormatFlags != 0) {
                // Position format flags:
                //   0xC0xx: float-based Vector3 (12 bytes per key)
                //   0xC2xx: SNORM int16-based Vector3 (6 bytes per key)
                // Low nibble: 0x40=ubyte time, 0x42=uint16 time with header
                local ubyte posFormat = posFormatFlags & 0x0F;

                FSeek(controllerStart + posTimeOffset);

                if (posFormat == 0x00) {
                    ubyte posTimeData[numPosKeys] <bgcolor=cDkGray, comment="Position time keys (ubyte)">;
                } else {
                    struct DBAAnimBlk_PosTimeBlock {
                        uint16 timeStart;
                        uint16 timeEnd;
                        uint32 marker;
                    } posTimeData <bgcolor=cDkGray, comment=Str("time: %d-%d, marker=0x%08X", this.timeStart, this.timeEnd, this.marker)>;
                }

                FSeek(controllerStart + posDataOffset);

                // Position format based on high byte:
                // 0xC0xx: float-based Vector3 (12 bytes per key), no header
                // 0xC1xx: 24-byte header + full SNORMVector3 (all channels, 6 bytes per key)
                // 0xC2xx: 24-byte header + packed SNORMs for active channels only
                local ubyte posHighByte = (posFormatFlags >> 8) & 0xFF;
                if (posHighByte == 0xC0) {
                    // Float Vector3 - no header
                    Vector3 positions[numPosKeys] <bgcolor=cLtGreen, comment=PrintVector3>;
                } else if (posHighByte == 0xC1) {
                    // SNORM with header - all channels present
                    PosHeader_C2_Ivo posHeader <bgcolor=cDkGreen, comment=PrintPosHeader_C2_Ivo>;
                    struct {
                        local int pk;
                        for (pk = 0; pk < numPosKeys; pk++) {
                            ScaledSNORMPos_Ivo position(posHeader.scale.x, posHeader.scale.y, posHeader.scale.z) <bgcolor=cLtGreen, comment=PrintScaledSNORMPos_Ivo>;
                        }
                    } positions <comment="Scaled SNORM positions">;
                } else if (posHighByte == 0xC2) {
                    // SNORM with header - read header first
                    PosHeader_C2_Ivo posHeader <bgcolor=cDkGreen, comment=PrintPosHeader_C2_Ivo>;

                    // Determine active channels
                    local int xActive = (posHeader.channelMask.x < 3.4e38) ? 1 : 0;
                    local int yActive = (posHeader.channelMask.y < 3.4e38) ? 1 : 0;
                    local int zActive = (posHeader.channelMask.z < 3.4e38) ? 1 : 0;
                    // Read packed SNORM positions (only active channels stored)
                    struct {
                        local int pk;
                        for (pk = 0; pk < numPosKeys; pk++) {
                            PackedSNORMPos_Ivo position(xActive, yActive, zActive, posHeader.scale.x, posHeader.scale.y, posHeader.scale.z) <bgcolor=cLtGreen, comment=PrintPackedSNORMPos_Ivo>;
                        }
                    } positions <comment="Packed SNORM positions">;
                } else {
                    // Unknown format - read as raw bytes (estimate 12 bytes per key)
                    ubyte posDataRaw[numPosKeys * 12] <bgcolor=cRed, comment="Unknown position format">;
                }
            }

            FSeek(savedPos);
        } controller <bgcolor=cLtYellow,
                      comment=Str("Rot=%d keys (flags=0x%04X), Pos=%d keys (flags=0x%04X)", this.numRotKeys, this.rotFormatFlags, this.numPosKeys, this.posFormatFlags)>;
    }

    // Seek to end of block
    FSeek(blockEnd);
};

string PrintDBABlock_Ivo(DBAAnimationBlock_Ivo &dba) {
    string result;
    local int posCount = 0;
    local int i;
    for (i = 0; i < dba.numBones; i++) {
        if (dba.controllers[i].posFormatFlags != 0) {
            posCount++;
        }
    }
    SPrintf(result, "#dba - %d bones (%d with pos), %d bytes",
        dba.header.boneCount, posCount, dba.header.dataSize);
    return result;
}

//------------------------------------------------
// Animation Path String
//------------------------------------------------

struct AnimPathString_Ivo {
    string path;
};

string PrintAnimPath_Ivo(AnimPathString_Ivo &p) {
    return p.path;
}

//------------------------------------------------
// DBA Animation Info Entry (44 bytes)
// Similar to CAF AnimInfo - metadata for each animation
//------------------------------------------------

struct DBAAnimInfoEntry_Ivo {
    uint32 flags;                    // Animation flags (usually 2)
    uint16 framesPerSecond;          // FPS (typically 30)
    uint16 numControllers;           // Number of bone controllers
    uint32 unknown1;                 // Unknown (often 0)
    uint32 unknown2;                 // Unknown (varies: 17, 25, etc.)
    Quaternion startRotation <comment=PrintQuaternion>;
    Vector3 startPosition <comment=PrintVector3>;
};  // Total: 4+2+2+4+4+16+12 = 44 bytes

string PrintDBAAnimInfo_Ivo(DBAAnimInfoEntry_Ivo &entry) {
    string result;
    SPrintf(result, "Flags:%d FPS:%d Controllers:%d Rot:(%.2f,%.2f,%.2f,%.2f)",
        entry.flags, entry.framesPerSecond, entry.numControllers,
        entry.startRotation.x, entry.startRotation.y, entry.startRotation.z, entry.startRotation.w);
    return result;
}

//------------------------------------------------
// DBA Animation Info Chunk (0xF7351608)
// Contains animation metadata and path strings
//------------------------------------------------

struct DBAAnimInfoChunk_Ivo {
    uint32 numAnimations <comment="Number of animations in this DBA">;

    // Animation info entries (44 bytes each)
    if (numAnimations > 0) {
        DBAAnimInfoEntry_Ivo animInfo[numAnimations] <bgcolor=cLtRed, comment=PrintDBAAnimInfo_Ivo>;
    }

    // Path strings (null-terminated, one per animation)
    local int i;
    for (i = 0; i < numAnimations; i++) {
        AnimPathString_Ivo animPath <bgcolor=cWhite, comment=PrintAnimPath_Ivo>;
    }
};

string PrintDBAAnimInfoChunk_Ivo(DBAAnimInfoChunk_Ivo &chunk) {
    string result;
    SPrintf(result, "DBA AnimInfo: %d animations", chunk.numAnimations);
    return result;
}

//------------------------------------------------
// DBA Animation Block
// Self-contained block with controller data for one animation
// Block size is given by blockSize field (includes 12-byte header)
//------------------------------------------------

struct DBABlock_Ivo {
    local int64 blockStart = FTell();

    char signature[4] <comment="'#dba' magic">;
    uint16 numControllers <comment="Number of bone controllers">;
    uint16 unknown <comment="Unknown (0xAA55)">;
    uint32 blockSize <comment="Total block size (including header)">;

    local int64 blockEnd = blockStart + blockSize;

    // Controller hashes - CRC32 of bone names
    if (numControllers > 0) {
        uint32 controllerHashes[numControllers] <bgcolor=cLtGreen, comment="CRC32 bone name hashes">;
    }

    // Controller entries with keyframe data (same as CAF format)
    local int c;
    for (c = 0; c < numControllers; c++) {
        struct DBABlockController_Ivo {
            // Track start of this controller - offsets are relative to here
            local int64 controllerStart = FTell();

            // Controller header (24 bytes)
            uint16 numRotKeys;
            uint16 rotFormatFlags;
            uint32 rotTimeOffset;
            uint32 rotDataOffset;
            uint16 numPosKeys;
            uint16 posFormatFlags;
            uint32 posTimeOffset;
            uint32 posDataOffset;

            // Save position after reading controller header
            local int64 savedPos = FTell();

            // Read rotation time and data if present
            if (numRotKeys > 0 && rotTimeOffset > 0) {
                FSeek(controllerStart + rotTimeOffset);
                local ubyte rotFormat = rotFormatFlags & 0x0F;

                if (rotFormat == 0x00) {
                    ubyte rotTimeData[numRotKeys] <bgcolor=cDkGray, comment="Rotation time keys (ubyte)">;
                } else {
                    AnimTimeHeader_Ivo rotTimeHeader <bgcolor=cDkGray, comment=PrintAnimTimeHeader_Ivo>;
                }

                FSeek(controllerStart + rotDataOffset);
                UncompressedQuat_Ivo rotations[numRotKeys] <bgcolor=cLtPurple, comment=PrintUncompressedQuat_Ivo>;
            }

            // Read position time and data if present
            if (numPosKeys > 0 && posFormatFlags != 0) {
                // Position format flags:
                //   0xC0xx: float-based Vector3 (12 bytes per key)
                //   0xC2xx: SNORM int16-based Vector3 (6 bytes per key)
                // Low nibble: 0x40=ubyte time, 0x42=uint16 time with header
                local ubyte posFormat = posFormatFlags & 0x0F;

                FSeek(controllerStart + posTimeOffset);

                if (posFormat == 0x00) {
                    ubyte posTimeData[numPosKeys] <bgcolor=cDkGray, comment="Position time keys (ubyte)">;
                } else {
                    struct DBABlk_PosTimeBlock {
                        uint16 timeStart;
                        uint16 timeEnd;
                        uint32 marker;
                    } posTimeData <bgcolor=cDkGray, comment=Str("time: %d-%d, marker=0x%08X", this.timeStart, this.timeEnd, this.marker)>;
                }

                FSeek(controllerStart + posDataOffset);

                // Position format based on high byte:
                // 0xC0xx: float-based Vector3 (12 bytes per key), no header
                // 0xC1xx: 24-byte header + full SNORMVector3 (all channels, 6 bytes per key)
                // 0xC2xx: 24-byte header + packed SNORMs for active channels only
                local ubyte posHighByte = (posFormatFlags >> 8) & 0xFF;
                if (posHighByte == 0xC0) {
                    // Float Vector3 - no header
                    Vector3 positions[numPosKeys] <bgcolor=cLtGreen, comment=PrintVector3>;
                } else if (posHighByte == 0xC1) {
                    // SNORM with header - all channels present
                    PosHeader_C2_Ivo posHeader <bgcolor=cDkGreen, comment=PrintPosHeader_C2_Ivo>;
                    struct {
                        local int pk;
                        for (pk = 0; pk < numPosKeys; pk++) {
                            ScaledSNORMPos_Ivo position(posHeader.scale.x, posHeader.scale.y, posHeader.scale.z) <bgcolor=cLtGreen, comment=PrintScaledSNORMPos_Ivo>;
                        }
                    } positions <comment="Scaled SNORM positions">;
                } else if (posHighByte == 0xC2) {
                    // SNORM with header - read header first
                    PosHeader_C2_Ivo posHeader <bgcolor=cDkGreen, comment=PrintPosHeader_C2_Ivo>;

                    // Determine active channels
                    local int xActive = (posHeader.channelMask.x < 3.4e38) ? 1 : 0;
                    local int yActive = (posHeader.channelMask.y < 3.4e38) ? 1 : 0;
                    local int zActive = (posHeader.channelMask.z < 3.4e38) ? 1 : 0;
                    // Read packed SNORM positions (only active channels stored)
                    struct {
                        local int pk;
                        for (pk = 0; pk < numPosKeys; pk++) {
                            PackedSNORMPos_Ivo position(xActive, yActive, zActive, posHeader.scale.x, posHeader.scale.y, posHeader.scale.z) <bgcolor=cLtGreen, comment=PrintPackedSNORMPos_Ivo>;
                        }
                    } positions <comment="Packed SNORM positions">;
                } else {
                    // Unknown format - read as raw bytes (estimate 12 bytes per key)
                    ubyte posDataRaw[numPosKeys * 12] <bgcolor=cRed, comment="Unknown position format">;
                }
            }

            // Restore position for next controller
            FSeek(savedPos);
        } controller <bgcolor=cLtYellow,
                      comment=Str("Rot=%d keys (flags=0x%04X), Pos=%d keys (flags=0x%04X)", this.numRotKeys, this.rotFormatFlags, this.numPosKeys, this.posFormatFlags)>;
    }

    // Position is now after all controller headers (24 bytes each)
    // The next #dba block (if any) starts here, not at blockEnd
};

string PrintDBABlock_Ivo2(DBABlock_Ivo &block) {
    string result;
    SPrintf(result, "#dba: %d controllers, size=%d bytes", block.numControllers, block.blockSize);
    return result;
}

//------------------------------------------------
// DBA Data Chunk (0x194FBC50)
// Contains one or more sequential #dba blocks
//------------------------------------------------

struct DbaDataChunk_Ivo {
    local int64 startPos = FTell();
    local char sig[4];

    // Total chunk size (includes everything from here to end of chunk)
    uint32 chunkSize <comment="Total chunk size">;

    local int64 chunkEnd = startPos + chunkSize;
    local int blockIndex = 0;

    // Parse sequential #dba blocks until we reach chunk end
    while (FTell() < chunkEnd) {
        ReadBytes(sig, FTell(), 4);
        if (sig[0] == '#' && sig[1] == 'd' && sig[2] == 'b' && sig[3] == 'a') {
            DBABlock_Ivo block <bgcolor=(blockIndex == 0 ? cLtBlue : cLtPurple), comment=PrintDBABlock_Ivo2>;
            blockIndex++;
        } else {
            break;
        }
    }
};

string PrintDbaDataChunk_Ivo(DbaDataChunk_Ivo &chunk) {
    string result;
    SPrintf(result, "DBA Data: %d bytes", chunk.chunkSize);
    return result;
}

#endif // CHUNKS_ANIMATION_BT

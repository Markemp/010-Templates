//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: PrintFunctions.bt
//   Authors: Geoff Gerber
//   Purpose: Display/comment functions for 010 Editor visualization
//------------------------------------------------

#ifndef DISPLAY_PRINTFUNCTIONS_BT
#define DISPLAY_PRINTFUNCTIONS_BT

#include "core/BaseTypes.bt"
#include "core/Utilities.bt"

//------------------------------------------------
// Matrix Print Functions
//------------------------------------------------

string PrintMatrix4x4(Matrix4x4 &m) {
    string result;
    SPrintf(result, "[[%f, %f, %f, %f] [%f, %f, %f, %f] [%f, %f, %f, %f] [%f, %f, %f, %f]]",
        m.m11, m.m12, m.m13, m.m14,
        m.m21, m.m22, m.m23, m.m24,
        m.m31, m.m32, m.m33, m.m34,
        m.m41, m.m42, m.m43, m.m44);
    return result;
}

string PrintMatrix3x4(Matrix3x4 &m) {
    string result;
    SPrintf(result, "[[%f, %f, %f, %f] [%f, %f, %f, %f] [%f, %f, %f, %f]]",
        m.m11, m.m12, m.m13, m.m14,
        m.m21, m.m22, m.m23, m.m24,
        m.m31, m.m32, m.m33, m.m34);
    return result;
}

string PrintMat3x4Trans(Matrix3x4 &m) {
    string result;
    SPrintf(result, "[%f, %f, %f]", m.m14, m.m24, m.m34);
    return result;
}

string PrintMatrix3x3(Matrix3x3 &m) {
    string result;
    SPrintf(result, "[[%f, %f, %f] [%f, %f, %f] [%f, %f, %f]]",
        m.m11, m.m12, m.m13,
        m.m21, m.m22, m.m23,
        m.m31, m.m32, m.m33);
    return result;
}

//------------------------------------------------
// Vector Print Functions
//------------------------------------------------

string PrintVector3(Vector3 &v) {
    string result;
    SPrintf(result, "%f, %f, %f", v.x, v.y, v.z);
    return result;
}

string PrintVector3Half(Vector3Half &v) {
    string result;
    SPrintf(result, "%f, %f, %f", v.x, v.y, v.z);
    return result;
}

string PrintVector3CryHalf(Vector3CryHalf &v) {
    string result;
    SPrintf(result, "%f, %f, %f",
        CryHalfToFloat(v.x), CryHalfToFloat(v.y), CryHalfToFloat(v.z));
    return result;
}

string PrintVector3Snorm(Vector3Snorm &v) {
    string result;
    SPrintf(result, "%f, %f, %f", v.x / 32767.0, v.y / 32767.0, v.z / 32767.0);
    return result;
}

string PrintVector4(Vector4 &v) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", v.x, v.y, v.z, v.w);
    return result;
}

string PrintVector4Snorm(Vector4Snorm &v) {
    string result;
    SPrintf(result, "x: %f, y: %f, z: %f, w: %f",
        Max(v.x / 32767.0, -1.0), Max(v.y / 32767.0, -1.0),
        Max(v.z / 32767.0, -1.0), Max(v.w / 32767.0, -1.0));
    return result;
}

string PrintQTangentSnorm(Vector4Snorm &v) {
    string result;
    // Decode SNORM values
    local float x = Max(v.x / 32767.0, -1.0);
    local float y = Max(v.y / 32767.0, -1.0);
    local float z = Max(v.z / 32767.0, -1.0);
    local float w = Max(v.w / 32767.0, -1.0);

    // Raw quaternion magnitude (before normalization)
    local float qMag = Sqrt(x*x + y*y + z*z + w*w);
    local string qMagStr = (qMag > 0.98 && qMag < 1.02) ? " [OK]" : " [BAD]";

    // Normalize the quaternion (required for proper TBN extraction)
    if (qMag > 0.0001) {
        x = x / qMag;
        y = y / qMag;
        z = z / qMag;
        w = w / qMag;
    }

    // Pre-compute common terms
    local float fTxx = 2.0 * x * x;
    local float fTyy = 2.0 * y * y;
    local float fTzz = 2.0 * z * z;
    local float fTxy = 2.0 * x * y;
    local float fTxz = 2.0 * x * z;
    local float fTyz = 2.0 * y * z;
    local float fTwx = 2.0 * w * x;
    local float fTwy = 2.0 * w * y;
    local float fTwz = 2.0 * w * z;

    // Extract all three axes of TBN matrix
    // X-axis (often Tangent or Normal depending on convention)
    local float ax_x = 1.0 - (fTyy + fTzz);
    local float ax_y = fTxy + fTwz;
    local float ax_z = fTxz - fTwy;

    // Y-axis
    local float ay_x = fTxy - fTwz;
    local float ay_y = 1.0 - (fTxx + fTzz);
    local float ay_z = fTyz + fTwx;

    // Z-axis
    local float az_x = fTxz + fTwy;
    local float az_y = fTyz - fTwx;
    local float az_z = 1.0 - (fTxx + fTyy);

    // Bitangent sign from w
    local string signStr = (w < 0) ? "-" : "+";

    SPrintf(result, "X:(%.2f,%.2f,%.2f) Y:(%.2f,%.2f,%.2f) Z:(%.2f,%.2f,%.2f) qMag=%.4f%s b:%s",
        ax_x, ax_y, ax_z, ay_x, ay_y, ay_z, az_x, az_y, az_z, qMag, qMagStr, signStr);
    return result;
}

string PrintVector4Bnorm(Vector4Bnorm &v) {
    string result;
    SPrintf(result, "x: %f, y: %f, z: %f, w: %f",
        Max(v.x / 127.0, -1.0), Max(v.y / 127.0, -1.0),
        Max(v.z / 127.0, -1.0), Max(v.w / 127.0, -1.0));
    return result;
}

string PrintVector4Unorm(Vector4Unorm &v) {
    string result;
    SPrintf(result, "x: %f, y: %f, z: %f, w: %f",
        v.x / 65535.0, v.y / 65535.0, v.z / 65535.0, v.w / 65535.0);
    return result;
}

string PrintQTangentUnorm(Vector4Unorm &v) {
    string result;
    // Decode UNORM values and remap from [0,1] to [-1,1]
    local float x = (v.x / 65535.0) * 2.0 - 1.0;
    local float y = (v.y / 65535.0) * 2.0 - 1.0;
    local float z = (v.z / 65535.0) * 2.0 - 1.0;
    local float w = (v.w / 65535.0) * 2.0 - 1.0;

    // Raw quaternion magnitude (before normalization)
    local float qMag = Sqrt(x*x + y*y + z*z + w*w);
    local string qMagStr = (qMag > 0.98 && qMag < 1.02) ? " [OK]" : " [BAD]";

    // Normalize the quaternion (required for proper TBN extraction)
    if (qMag > 0.0001) {
        x = x / qMag;
        y = y / qMag;
        z = z / qMag;
        w = w / qMag;
    }

    // Pre-compute common terms
    local float fTxx = 2.0 * x * x;
    local float fTyy = 2.0 * y * y;
    local float fTzz = 2.0 * z * z;
    local float fTxy = 2.0 * x * y;
    local float fTxz = 2.0 * x * z;
    local float fTyz = 2.0 * y * z;
    local float fTwx = 2.0 * w * x;
    local float fTwy = 2.0 * w * y;
    local float fTwz = 2.0 * w * z;

    // Extract all three axes of TBN matrix
    local float ax_x = 1.0 - (fTyy + fTzz);
    local float ax_y = fTxy + fTwz;
    local float ax_z = fTxz - fTwy;

    local float ay_x = fTxy - fTwz;
    local float ay_y = 1.0 - (fTxx + fTzz);
    local float ay_z = fTyz + fTwx;

    local float az_x = fTxz + fTwy;
    local float az_y = fTyz - fTwx;
    local float az_z = 1.0 - (fTxx + fTyy);

    // Bitangent sign from w
    local string signStr = (w < 0) ? "-" : "+";

    SPrintf(result, "X:(%.2f,%.2f,%.2f) Y:(%.2f,%.2f,%.2f) Z:(%.2f,%.2f,%.2f) qMag=%.4f%s b:%s",
        ax_x, ax_y, ax_z, ay_x, ay_y, ay_z, az_x, az_y, az_z, qMag, qMagStr, signStr);
    return result;
}

//------------------------------------------------
// 10-10-10-2 Packed Format Print Functions
//------------------------------------------------

string PrintPacked1010102(Packed1010102 &p) {
    string result;
    // Extract 10-bit signed values and 2-bit W
    local int rawX = p.packed & 0x3FF;
    local int rawY = (p.packed >> 10) & 0x3FF;
    local int rawZ = (p.packed >> 20) & 0x3FF;
    local int rawW = (p.packed >> 30) & 0x3;

    // Sign extend 10-bit to signed int (if bit 9 is set, it's negative)
    if (rawX >= 512) rawX = rawX - 1024;
    if (rawY >= 512) rawY = rawY - 1024;
    if (rawZ >= 512) rawZ = rawZ - 1024;

    // Normalize to [-1, 1] range (divide by 511 for signed)
    local float x = rawX / 511.0;
    local float y = rawY / 511.0;
    local float z = rawZ / 511.0;

    local float mag = Sqrt(x*x + y*y + z*z);
    local string magStr = (mag > 0.98 && mag < 1.02) ? " [OK]" : " [BAD]";

    SPrintf(result, "(%.3f, %.3f, %.3f) w=%d mag=%.4f%s", x, y, z, rawW, mag, magStr);
    return result;
}

// Decode tangent frame with W bits controlling signs
string PrintTangent1010102(Packed1010102 &p) {
    string result;
    local int rawX = p.packed & 0x3FF;
    local int rawY = (p.packed >> 10) & 0x3FF;
    local int rawZ = (p.packed >> 20) & 0x3FF;
    local int rawW = (p.packed >> 30) & 0x3;

    if (rawX >= 512) rawX = rawX - 1024;
    if (rawY >= 512) rawY = rawY - 1024;
    if (rawZ >= 512) rawZ = rawZ - 1024;

    local float x = rawX / 511.0;
    local float y = rawY / 511.0;
    local float z = rawZ / 511.0;

    // W bits might encode sign flips:
    // bit 0 (w & 1): possibly X or Y sign
    // bit 1 (w & 2): possibly Z sign (0 = negate, 1 = keep)
    if ((rawW & 2) == 0) z = -z;

    local float mag = Sqrt(x*x + y*y + z*z);
    local string magStr = (mag > 0.98 && mag < 1.02) ? " [OK]" : " [BAD]";

    SPrintf(result, "N:(%.3f, %.3f, %.3f) w=%d mag=%.4f%s", x, y, z, rawW, mag, magStr);
    return result;
}

// Decode Ivo tangent frame - determines axis from byte patterns (simple axis-aligned version)
string PrintIvoTangentFrame(IvoTangentFrame &tf) {
    string result;
    local float nx = 0, ny = 0, nz = 0;
    local string axis = "?";

    local int word2Bit15 = (tf.word2 >> 15) & 1;
    local int word0Bit15 = (tf.word0 >> 15) & 1;
    local int sign1 = (tf.word1 >> 15) & 1;
    local int sign3 = (tf.word3 >> 15) & 1;

    if (word2Bit15 == 0) {
        axis = "Z";
        nz = (sign3 == 1) ? 1.0 : -1.0;
    } else if (word0Bit15 == 0) {
        axis = "X";
        nx = (sign1 == 1) ? 1.0 : -1.0;
    } else {
        axis = "Y";
        ny = (sign1 == 1) ? -1.0 : 1.0;
    }

    SPrintf(result, "N:(%.0f, %.0f, %.0f) axis=%s", nx, ny, nz, axis);
    return result;
}

// Smallest-three quaternion decoding for QTangent
string PrintSmallestThreeQTangent(IvoTangentFrame &tf) {
    string result;

    // Combine words into uint32 values
    local uint32 value1 = tf.word0 | ((uint32)tf.word1 << 16);
    local uint32 value2 = tf.word2 | ((uint32)tf.word3 << 16);

    // Try interpreting as two 10-10-10-2 SNORM vectors (Tangent and Bitangent)
    // Then compute Normal = Tangent x Bitangent

    // Extract tangent from value1
    local int tx_raw = value1 & 0x3FF;
    local int ty_raw = (value1 >> 10) & 0x3FF;
    local int tz_raw = (value1 >> 20) & 0x3FF;

    // Sign extend 10-bit values (512-1023 are negative)
    if (tx_raw > 511) tx_raw = tx_raw - 1024;
    if (ty_raw > 511) ty_raw = ty_raw - 1024;
    if (tz_raw > 511) tz_raw = tz_raw - 1024;

    // Normalize to [-1, 1] range using 511 scale
    local float tx = tx_raw / 511.0;
    local float ty = ty_raw / 511.0;
    local float tz = tz_raw / 511.0;

    // Normalize tangent vector
    local float t_len = Sqrt(tx*tx + ty*ty + tz*tz);
    if (t_len > 0.0001) { tx = tx/t_len; ty = ty/t_len; tz = tz/t_len; }

    // Extract bitangent from value2
    local int bx_raw = value2 & 0x3FF;
    local int by_raw = (value2 >> 10) & 0x3FF;
    local int bz_raw = (value2 >> 20) & 0x3FF;

    if (bx_raw > 511) bx_raw = bx_raw - 1024;
    if (by_raw > 511) by_raw = by_raw - 1024;
    if (bz_raw > 511) bz_raw = bz_raw - 1024;

    local float bx = bx_raw / 511.0;
    local float by = by_raw / 511.0;
    local float bz = bz_raw / 511.0;

    // Normalize bitangent vector
    local float b_len = Sqrt(bx*bx + by*by + bz*bz);
    if (b_len > 0.0001) { bx = bx/b_len; by = by/b_len; bz = bz/b_len; }

    // Compute normal as cross product: N = T x B
    local float nx = ty*bz - tz*by;
    local float ny = tz*bx - tx*bz;
    local float nz = tx*by - ty*bx;

    // Normalize the normal
    local float n_len = Sqrt(nx*nx + ny*ny + nz*nz);
    if (n_len > 0.0001) { nx = nx/n_len; ny = ny/n_len; nz = nz/n_len; }

    SPrintf(result, "N:(%.2f,%.2f,%.2f) T:(%.2f,%.2f,%.2f) B:(%.2f,%.2f,%.2f)",
        nx, ny, nz, tx, ty, tz, bx, by, bz);
    return result;
}

//------------------------------------------------
// Quaternion Print Functions
//------------------------------------------------

string PrintQuaternion(Quaternion &q) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", q.x, q.y, q.z, q.w);
    return result;
}

string PrintQuatT(QuatT &qt) {
    string result;
    SPrintf(result, "q(%f, %f, %f, %f) t(%f, %f, %f)",
        qt.q.x, qt.q.y, qt.q.z, qt.q.w,
        qt.t.x, qt.t.y, qt.t.z);
    return result;
}

string PrintSmallTree48BitQuat(SmallTree48BitQuat &q) {
    // Decode SmallTree48BitQuat compression
    // Constants from CryEngine
    local float MAX_15BITf = 23170.0;
    local float RANGE_15BIT = 0.707106781186;

    // Reconstruct the 3 ushorts from raw bytes
    local uint m1 = q.data[0] | ((uint)q.data[1] << 8);
    local uint m2 = q.data[2] | ((uint)q.data[3] << 8);
    local uint m3 = q.data[4] | ((uint)q.data[5] << 8);

    // Combine into 64-bit value (use two 32-bit parts since 010 has limited 64-bit support)
    // v64 = m3 << 32 | m2 << 16 | m1
    // Low 32 bits: m2 << 16 | m1
    // High 16 bits: m3
    local uint low32 = (m2 << 16) | m1;
    local uint high16 = m3;

    // maxComponentIndex is at bits 46-47
    // Bit 46 is in high16 at bit 14, bit 47 at bit 15
    local int maxIdx = (high16 >> 14) & 0x3;

    // Extract three 15-bit packed values
    // Bits 0-14: first component
    // Bits 15-29: second component
    // Bits 30-44: third component
    local uint packed0 = low32 & 0x7FFF;
    local uint packed1 = (low32 >> 15) & 0x7FFF;
    local uint packed2 = ((low32 >> 30) | (high16 << 2)) & 0x7FFF;

    // Decode the three packed values
    local float decoded0 = packed0 / MAX_15BITf - RANGE_15BIT;
    local float decoded1 = packed1 / MAX_15BITf - RANGE_15BIT;
    local float decoded2 = packed2 / MAX_15BITf - RANGE_15BIT;

    // Assign to component array based on maxIdx
    local float comp0, comp1, comp2, comp3;
    local int srcIdx = 0;
    local int i;
    for (i = 0; i < 4; i++) {
        if (i == maxIdx) continue;
        if (srcIdx == 0) {
            if (i == 0) comp0 = decoded0;
            else if (i == 1) comp1 = decoded0;
            else if (i == 2) comp2 = decoded0;
            else comp3 = decoded0;
        } else if (srcIdx == 1) {
            if (i == 0) comp0 = decoded1;
            else if (i == 1) comp1 = decoded1;
            else if (i == 2) comp2 = decoded1;
            else comp3 = decoded1;
        } else {
            if (i == 0) comp0 = decoded2;
            else if (i == 1) comp1 = decoded2;
            else if (i == 2) comp2 = decoded2;
            else comp3 = decoded2;
        }
        srcIdx++;
    }

    // Reconstruct the max component: sqrt(1 - sum of squares)
    local float sqrsum = comp0*comp0 + comp1*comp1 + comp2*comp2 + comp3*comp3;
    local float maxComp = Sqrt(Max(0.0, 1.0 - sqrsum));

    if (maxIdx == 0) comp0 = maxComp;
    else if (maxIdx == 1) comp1 = maxComp;
    else if (maxIdx == 2) comp2 = maxComp;
    else comp3 = maxComp;

    string result;
    SPrintf(result, "x: %.4f, y: %.4f, z: %.4f, w: %.4f", comp0, comp1, comp2, comp3);
    return result;
}

string PrintSmallTree64BitQuat(SmallTree64BitQuat &q) {
    // Decode SmallTree64BitQuat compression
    // Constants from CryEngine
    local float MAX_20BITf = 741454.0;
    local float RANGE_20BIT = 0.707106781186;

    // Reconstruct the 2 uints from raw bytes
    local uint m1 = q.data[0] | ((uint)q.data[1] << 8) | ((uint)q.data[2] << 16) | ((uint)q.data[3] << 24);
    local uint m2 = q.data[4] | ((uint)q.data[5] << 8) | ((uint)q.data[6] << 16) | ((uint)q.data[7] << 24);

    // maxComponentIndex is at bits 62-63 (in m2 bits 30-31)
    local int maxIdx = (m2 >> 30) & 0x3;

    // Extract three 20-bit packed values
    // Bits 0-19: first component (all in m1)
    // Bits 20-39: second component (spans m1 and m2)
    // Bits 40-59: third component (in m2)
    local uint packed0 = m1 & 0xFFFFF;
    local uint packed1 = ((m1 >> 20) | (m2 << 12)) & 0xFFFFF;
    local uint packed2 = (m2 >> 8) & 0xFFFFF;

    // Decode the three packed values
    local float decoded0 = packed0 / MAX_20BITf - RANGE_20BIT;
    local float decoded1 = packed1 / MAX_20BITf - RANGE_20BIT;
    local float decoded2 = packed2 / MAX_20BITf - RANGE_20BIT;

    // Assign to component array based on maxIdx
    local float comp0, comp1, comp2, comp3;
    local int srcIdx = 0;
    local int i;
    for (i = 0; i < 4; i++) {
        if (i == maxIdx) continue;
        if (srcIdx == 0) {
            if (i == 0) comp0 = decoded0;
            else if (i == 1) comp1 = decoded0;
            else if (i == 2) comp2 = decoded0;
            else comp3 = decoded0;
        } else if (srcIdx == 1) {
            if (i == 0) comp0 = decoded1;
            else if (i == 1) comp1 = decoded1;
            else if (i == 2) comp2 = decoded1;
            else comp3 = decoded1;
        } else {
            if (i == 0) comp0 = decoded2;
            else if (i == 1) comp1 = decoded2;
            else if (i == 2) comp2 = decoded2;
            else comp3 = decoded2;
        }
        srcIdx++;
    }

    // Reconstruct the max component: sqrt(1 - sum of squares)
    local float sqrsum = comp0*comp0 + comp1*comp1 + comp2*comp2 + comp3*comp3;
    local float maxComp = Sqrt(Max(0.0, 1.0 - sqrsum));

    if (maxIdx == 0) comp0 = maxComp;
    else if (maxIdx == 1) comp1 = maxComp;
    else if (maxIdx == 2) comp2 = maxComp;
    else comp3 = maxComp;

    string result;
    SPrintf(result, "x: %.4f, y: %.4f, z: %.4f, w: %.4f", comp0, comp1, comp2, comp3);
    return result;
}

string PrintSmallTree64BitExtQuat(SmallTree64BitExtQuat &q) {
    // Decode SmallTree64BitExtQuat compression
    // First two components use 21 bits, third uses 20 bits
    local float MAX_20BITf = 741454.0;
    local float RANGE_20BIT = 0.707106781186;
    local float MAX_21BITf = 1482909.0;
    local float RANGE_21BIT = 0.707106781186;

    // Reconstruct the 2 uints from raw bytes
    local uint m1 = q.data[0] | ((uint)q.data[1] << 8) | ((uint)q.data[2] << 16) | ((uint)q.data[3] << 24);
    local uint m2 = q.data[4] | ((uint)q.data[5] << 8) | ((uint)q.data[6] << 16) | ((uint)q.data[7] << 24);

    // maxComponentIndex is at bits 62-63 (in m2 bits 30-31)
    local int maxIdx = (m2 >> 30) & 0x3;

    // Extract packed values: 21 bits, 21 bits, 20 bits
    // Bits 0-20: first component (21 bits)
    // Bits 21-41: second component (21 bits)
    // Bits 42-61: third component (20 bits)
    local uint packed0 = m1 & 0x1FFFFF;
    local uint packed1 = ((m1 >> 21) | (m2 << 11)) & 0x1FFFFF;
    local uint packed2 = (m2 >> 10) & 0xFFFFF;

    // Decode: first two use 21-bit constants, third uses 20-bit
    local float decoded0 = packed0 / MAX_21BITf - RANGE_21BIT;
    local float decoded1 = packed1 / MAX_21BITf - RANGE_21BIT;
    local float decoded2 = packed2 / MAX_20BITf - RANGE_20BIT;

    // Assign to component array based on maxIdx
    local float comp0, comp1, comp2, comp3;
    local int srcIdx = 0;
    local int i;
    for (i = 0; i < 4; i++) {
        if (i == maxIdx) continue;
        if (srcIdx == 0) {
            if (i == 0) comp0 = decoded0;
            else if (i == 1) comp1 = decoded0;
            else if (i == 2) comp2 = decoded0;
            else comp3 = decoded0;
        } else if (srcIdx == 1) {
            if (i == 0) comp0 = decoded1;
            else if (i == 1) comp1 = decoded1;
            else if (i == 2) comp2 = decoded1;
            else comp3 = decoded1;
        } else {
            if (i == 0) comp0 = decoded2;
            else if (i == 1) comp1 = decoded2;
            else if (i == 2) comp2 = decoded2;
            else comp3 = decoded2;
        }
        srcIdx++;
    }

    // Reconstruct the max component: sqrt(1 - sum of squares)
    local float sqrsum = comp0*comp0 + comp1*comp1 + comp2*comp2 + comp3*comp3;
    local float maxComp = Sqrt(Max(0.0, 1.0 - sqrsum));

    if (maxIdx == 0) comp0 = maxComp;
    else if (maxIdx == 1) comp1 = maxComp;
    else if (maxIdx == 2) comp2 = maxComp;
    else comp3 = maxComp;

    string result;
    SPrintf(result, "x: %.4f, y: %.4f, z: %.4f, w: %.4f", comp0, comp1, comp2, comp3);
    return result;
}

//------------------------------------------------
// Key Time Print Functions
//------------------------------------------------

string PrintByteKeyTime(ByteKeyTime &k) {
    string result;
    SPrintf(result, "%d", k.time);
    return result;
}

string PrintUint16KeyTime(Uint16KeyTime &k) {
    string result;
    SPrintf(result, "%d", k.time);
    return result;
}

//------------------------------------------------
// Color Print Functions
//------------------------------------------------

string PrintColorRGBA(ColorRGBA &c) {
    string result;
    SPrintf(result, "%d, %d, %d, %d", c.r, c.g, c.b, c.a);
    return result;
}

string PrintColorRGBAFloat(ColorRGBA &c) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", c.r / 255.0, c.g / 255.0, c.b / 255.0, c.a / 255.0);
    return result;
}

//------------------------------------------------
// UV Print Functions
//------------------------------------------------

string PrintUV(UV &uv) {
    string result;
    SPrintf(result, "%f, %f", uv.u, uv.v);
    return result;
}

string PrintUVHalf(UVHalf &uv) {
    string result;
    SPrintf(result, "%f, %f", uv.u, uv.v);
    return result;
}

string PrintUVCryHalf(UVCryHalf &uv) {
    string result;
    SPrintf(result, "%f, %f", CryHalfToFloat(uv.u), CryHalfToFloat(uv.v));
    return result;
}

//------------------------------------------------
// Normal Print Functions
//------------------------------------------------

string PrintCryNormal(CryNormal &n) {
    string result;
    SPrintf(result, "%f, %f", n.x / 32767.0, n.y / 32767.0);
    return result;
}

//------------------------------------------------
// Tangent Print Functions
//------------------------------------------------

string PrintTangentByte(TangentByte &t) {
    string result;
    SPrintf(result, "%f, %f, %f, %f", t.x / 127.0, t.y / 127.0, t.z / 127.0, t.w / 127.0);
    return result;
}

string PrintTangentBitangent(TangentBitangent &d) {
    string result;
    SPrintf(result, "Tangent: x: %f, y: %f, z: %f, w: %f, Bitangent: x: %f, y: %f, z: %f, w: %f",
        d.tangent.x / 32767.0, d.tangent.y / 32767.0, d.tangent.z / 32767.0, d.tangent.w / 32767.0,
        d.bitangent.x / 32767.0, d.bitangent.y / 32767.0, d.bitangent.z / 32767.0, d.bitangent.w / 32767.0);
    return result;
}

//------------------------------------------------
// Bounding Box Print Functions
//------------------------------------------------

string PrintBBox(BBox &bbox) {
    string result;
    SPrintf(result, "Min: %f, %f, %f, Max: %f, %f, %f",
        bbox.min.x, bbox.min.y, bbox.min.z,
        bbox.max.x, bbox.max.y, bbox.max.z);
    return result;
}

//------------------------------------------------
// CryHalf Print Functions
//------------------------------------------------

string PrintCryHalf(CryHalf &h) {
    string result;
    SPrintf(result, "x: %d, y: %d", h.x, h.y);
    return result;
}

//------------------------------------------------
// Animation Helper Functions
//------------------------------------------------

int GetRotationSize(ubyte format) {
    switch (format) {
        case eNoCompress:
        case eNoCompressQuat:
            return 16;  // 4 floats (w,x,y,z)
        case eSmallTree48BitQuat:
            return 6;
        case eSmallTree64BitQuat:
        case eSmallTree64BitExtQuat:
            return 8;
        default:
            return 16;
    }
}

int GetPositionSize(ubyte format) {
    switch (format) {
        case eNoCompress:
        case eNoCompressVec3:
            return 12;  // 3 floats (x,y,z)
        default:
            return 12;
    }
}

int GetTimeKeySize(ubyte format) {
    switch (format) {
        case eF32:
        case eF32StartStop:
            return 4;
        case eUINT16:
        case eUINT16StartStop:
        case eBitset:
            return 2;
        case eByte:
        case eByteStartStop:
            return 1;
        default:
            return 4;
    }
}

//------------------------------------------------
// Default Version Helper
//------------------------------------------------

uint SetDefaultVersion() {
    return 0x0800;
}

#endif // DISPLAY_PRINTFUNCTIONS_BT
